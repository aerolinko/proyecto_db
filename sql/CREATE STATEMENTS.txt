CREATE TABLE ESTADO(
                       estado_id serial,
                       nombre varchar(50) NOT NULL,
                       descripcion varchar(255) NOT NULL,
                       constraint pk_estado_id primary key (estado_id)
);

CREATE TABLE REPOSICION_ANAQUEL(
                                   reposicion_anaquel_id serial,
                                   fecha_entrega DATE,
                                   fecha DATE NOT NULL,
                                   constraint pk_reposicion_anaquel_id primary key (reposicion_anaquel_id)
);

CREATE TABLE LUGAR(
                      lugar_id serial,
                      nombre varchar(50) NOT NULL,
                      tipo varchar(50) NOT NULL,
                      fk_lugar integer ,
                      constraint pk_lugar_id primary key (lugar_id),
                      constraint fk_lugar foreign key(fk_lugar) references LUGAR(lugar_id),
                      constraint check_lugar_tipo check ( tipo IN('parroquia','estado','municipio'))
);

CREATE TABLE CARACTERISTICA(
                               caracteristica_id serial,
                               nombre varchar(50) NOT NULL,
                               tipo varchar(50) NOT NULL,
                               descripcion varchar(255),
                               constraint pk_caracteristica_id primary key (caracteristica_id),
                               constraint check_tipo_caracteristica check ( tipo IN('aroma','sabor','sensacion','color') )
);

CREATE TABLE ESTILO_CERVEZA(
                               estilo_cerveza_id serial,
                               nombre varchar(50) NOT NULL,
                               constraint pk_estilo_cerveza_id primary key (estilo_cerveza_id)
);

CREATE TABLE PERMISO(
                        permiso_id serial,
                        descripcion varchar(255) NOT NULL,
                        constraint pk_permiso_id primary key (permiso_id)
);

CREATE TABLE TIPO_INGREDIENTE(
                                 tipo_ingrediente_id serial,
                                 nombre varchar(50) NOT NULL,
                                 constraint pk_tipo_ingrediente_id primary key (tipo_ingrediente_id)
);

CREATE TABLE CARGO(
                      cargo_id serial,
                      nombre varchar(50) NOT NULL,
                      constraint pk_cargo_id primary key (cargo_id)
);

CREATE TABLE HORARIO(
                        horario_id serial,
                        hora_inicio time NOT NULL,
                        hora_fin time NOT NULL,
                        dia varchar(50),
                        constraint pk_horario_id primary key (horario_id),
                        constraint check_horario_dia check ( dia IN('lunes','martes','miercoles','jueves','viernes','sabado','domingo'))
);

CREATE TABLE BENEFICIO(
                          beneficio_id serial,
                          nombre varchar(50) NOT NULL,
                          descripcion varchar(255) NOT NULL,
                          constraint pk_beneficio_id primary key (beneficio_id)
);

CREATE TABLE TIPO_EVENTO(
                            tipo_evento_id serial,
                            nombre varchar(50) NOT NULL,
                            constraint pk_tipo_evento_id primary key (tipo_evento_id)
);

CREATE TABLE PREMIACION(
                           premiacion_id serial,
                           nombre varchar(50) NOT NULL,
                           fecha DATE NOT NULL,
                           hora_inicio time NOT NULL,
                           hora_fin time NOT NULL,
                           constraint pk_premiacion_id primary key (premiacion_id)
);

CREATE TABLE ACAUCAB(
                        acaucab_id serial,
                        direccion varchar(255) NOT NULL,
                        denomiancion_comercial varchar(100) NOT NULL,
                        RIF varchar(12) NOT NULL,
                        razon_social varchar(100) NOT NULL,
                        fk_lugar integer NOT NULL,
                        constraint pk_acaucab_id primary key (acaucab_id),
                        constraint fk_lugar_acaucab foreign key (fk_lugar) references LUGAR(lugar_id)
);

CREATE TABLE ALMACEN(
                        almacen_id serial,
                        capacidad integer NOT NULL,
                        direccion varchar(255) NOT NULL,
                        fk_lugar integer,
                        fk_acaucab integer,
                        constraint pk_almacen_id primary key (almacen_id),
                        constraint fk_lugar_almacen foreign key (fk_lugar) references LUGAR(lugar_id),
                        constraint fk_acaucab_almacen foreign key (fk_acaucab) references ACAUCAB(acaucab_id)
);

CREATE TABLE ESTADO_REPOSICION_ANAQUEL(
                                          estado_reposicion_anaquel_id serial,
                                          fecha_inicio DATE NOT NULL,
                                          fecha_fin DATE,
                                          fk_estado integer NOT NULL,
                                          fk_reposicion_anaquel integer NOT NULL,
                                          constraint pk_estado_reposicion_anaquel_id primary key (estado_reposicion_anaquel_id),
                                          constraint fk_estado_estado_reposicion_anaquel foreign key (fk_estado) references ESTADO(estado_id),
                                          constraint fk_reposicion_estado_reposicion_anaquel foreign key (fk_reposicion_anaquel) references REPOSICION_ANAQUEL(reposicion_anaquel_id)
);

CREATE TABLE PASILLO(
                        pasillo_id serial,
                        nombre varchar(50) NOT NULL,
                        fk_acaucab integer NOT NULL,
                        constraint pk_pasillo_id primary key (pasillo_id),
                        constraint fk_acaucab_pasillo foreign key (fk_acaucab) references ACAUCAB(acaucab_id)
);

CREATE TABLE ANAQUEL(
                        anaquel_id serial,
                        estantes integer NOT NULL,
                        capacidad integer NOT NULL,
                        fk_pasillo integer NOT NULL,
                        constraint pk_anaquel_id primary key (anaquel_id),
                        constraint fk_pasillo_anaquel foreign key (fk_pasillo) references PASILLO(pasillo_id)
);

CREATE TABLE TIPO_CERVEZA(
                             tipo_cerveza_id serial,
                             nombre varchar(50) NOT NULL,
                             constraint pk_tipo_cerveza primary key (tipo_cerveza_id)
);

CREATE TABLE PRESENTACION(
                             presentacion_id serial,
                             material varchar(50) NOT NULL,
                             cap_volumen integer NOT NULL,
                             constraint pk_presentacion_id primary key (presentacion_id),
                             constraint check_presentacion_material check ( material IN('aluminio','vidrio','plastico'))
);

CREATE TABLE INGREDIENTE(
                            ingrediente_id serial,
                            nombre varchar(50) NOT NULL,
                            fk_tipo_ingrediente integer NOT NULL,
                            constraint pk_ingrediente_id primary key (ingrediente_id),
                            constraint fk_tipo_ingrediente_ingrediente foreign key (fk_tipo_ingrediente) references TIPO_INGREDIENTE(tipo_ingrediente_id)
);

CREATE TABLE ROL(
                    rol_id serial,
                    descripcion varchar(255) NOT NULL,
                    nombre varchar(50) NOT NULL,
                    constraint pk_rol_id primary key (rol_id)
);

CREATE TABLE ROL_PERMISO(
                            rol_permiso_id serial,
                            fk_rol integer NOT NULL,
                            fk_permiso integer NOT NULL,
                            constraint pk_rol_permiso_id primary key (rol_permiso_id),
                            constraint fk_rol_rol_permiso foreign key (fk_rol) references ROL(rol_id) ON DELETE CASCADE,
                            constraint fk_permiso_rol_permiso foreign key (fk_permiso) references PERMISO(permiso_id)
);

CREATE TABLE EMPLEADO(
                         empleado_id serial,
                         cedula integer NOT NULL,
                         primer_nombre varchar(50) NOT NULL,
                         primer_apellido varchar(50) NOT NULL,
                         direccion varchar(255) NOT NULL,
                         segundo_nombre varchar(50),
                         segundo_apellido varchar(50),
                         fecha_contrato DATE NOT NULL,
                         fk_lugar integer NOT NULL,
                         constraint pk_empleado_id primary key (empleado_id),
                         constraint fk_lugar_empleado foreign key (fk_lugar) references LUGAR(lugar_id)
);

CREATE TABLE HORARIO_EMPLEADO(
                                 horario_empleado_id serial,
                                 fk_empleado integer NOT NULL,
                                 fk_horario integer NOT NULL,
                                 constraint pk_horario_empleado_id primary key (horario_empleado_id),
                                 constraint fk_empleado_horario_empleado foreign key (fk_empleado) references EMPLEADO(empleado_id),
                                 constraint  fk_horario_horario_empleado foreign key (fk_horario) references HORARIO(horario_id)
);

CREATE TABLE ASISTENCIA(
                           asistencia_id serial,
                           fecha_hora_entrada timestamp,
                           fecha_hora_salida timestamp,
                           fk_empleado integer NOT NULL,
                           constraint pk_asistencia_id primary key (asistencia_id),
                           constraint fk_empleado_asistencia foreign key (fk_empleado) references EMPLEADO(empleado_id)
);

CREATE TABLE VACACION(
                         vacacion_id serial,
                         fecha_inicio DATE NOT NULL,
                         fecha_fin DATE NOT NULL,
                         fk_empleado integer NOT NULL,
                         constraint pk_vacacion_id primary key (vacacion_id),
                         constraint fk_empleado_vacacion foreign key (fk_empleado) references EMPLEADO(empleado_id)
);

CREATE TABLE BENEFICIO_EMPLEADO(
                                   beneficio_empleado_id serial,
                                   monto integer NOT NULL,
                                   fk_beneficio integer NOT NULL,
                                   fk_empleado integer NOT NULL,
                                   constraint pk_beneficio_empleado_id primary key (beneficio_empleado_id),
                                   constraint fk_beneficio_beneficio_empleado foreign key (fk_beneficio) references BENEFICIO(beneficio_id),
                                   constraint fk_empleado_beneficio_emeplado foreign key (fk_empleado) references EMPLEADO(empleado_id)
);

CREATE TABLE EVENTO(
                       evento_id serial,
                       nombre varchar(50) NOT NULL,
                       capacidad integer NOT NULL,
                       direccion varchar(255) NOT NULL,
                       entrada_paga boolean default 'f',
                       fecha_inicio DATE NOT NULL,
                       fecha_fin DATE NOT NULL,
                       estacionamiento boolean default 'f',
                       numero_entradas integer NOT NULL,
                       precio_entradas integer,
                       fk_tipo_evento integer NOT NULL,
                       fk_lugar integer NOT NULL,
                       constraint pk_evento_id primary key (evento_id),
                       constraint fk_tipo_evento_evento foreign key (fk_tipo_evento) references TIPO_EVENTO(tipo_evento_id),
                       constraint fk_lugar_evento foreign key (fk_lugar) references LUGAR(lugar_id)
);

CREATE TABLE EVENTO_EMPLEADO(
                                evento_empleado_id serial,
                                fk_evento integer NOT NULL,
                                fk_empleado integer NOT NULL,
                                constraint pk_evento_empleado_id primary key (evento_empleado_id),
                                constraint fk_evento_evento_empleado foreign key (fk_evento) references EVENTO(evento_id),
                                constraint  fk_empleado_evento_empleado foreign key (fk_empleado) references EMPLEADO(empleado_id)
);

CREATE TABLE PREMIACION_EVENTO(
                                  premiacion_evento_id serial,
                                  fk_evento integer NOT NULL,
                                  fk_premiacion integer NOT NULL,
                                  constraint fk_evento_premiacion_empleado foreign key (fk_evento) references EVENTO(evento_id),
                                  constraint fk_premiacion_premiacion_empleado foreign key (fk_premiacion) references PREMIACION(premiacion_id),
                                  constraint pk_premiacion_evento_id primary key (premiacion_evento_id)
);

CREATE TABLE JUEZ(
                     juez_id serial,
                     primer_nombre varchar(50) NOT NULL,
                     primer_apellido varchar(50) NOT NULL,
                     area varchar(255) NOT NULL,
                     fk_premiacion_evento integer NOT NULL,
                     constraint pk_juez_id primary key (juez_id),
                     constraint fk_premiacion_evento_juez foreign key (fk_premiacion_evento) references PREMIACION_EVENTO(premiacion_evento_id)
);

CREATE TABLE DEPARTAMENTO(
                             departamento_id serial,
                             nombre varchar(50) NOT NULL,
                             fk_acaucab integer NOT NULL,
                             constraint pk_departamento_id primary key (departamento_id),
                             constraint fk_acaucab_departamento foreign key (fk_acaucab) references ACAUCAB(acaucab_id)
);

CREATE TABLE DEPARTAMENTO_EMPLEADO(
                                      departamento_empleado_id serial,
                                      fecha_inicio DATE NOT NULL,
                                      fecha_fin DATE,
                                      salario integer NOT NULL,
                                      fk_departamento integer NOT NULL,
                                      fk_empleado integer NOT NULL,
                                      fk_cargo integer NOT NULL,
                                      constraint pk_departamento_empleado_id primary key (departamento_empleado_id),
                                      constraint fk_empleado_departamento_empleado foreign key (fk_empleado) references EMPLEADO(empleado_id),
                                      constraint fk_departamento_departamento_emplado foreign key (fk_departamento) references DEPARTAMENTO(departamento_id),
                                      constraint fk_cargo_departamento_emplado foreign key (fk_cargo) references CARGO(cargo_id)
);

CREATE TABLE RECETA(
                       receta_id serial,
                       nombre varchar(50) NOT NULL,
                       descripcion varchar(255) NOT NULL,
                       constraint pk_receta_id primary key (receta_id)
);

CREATE TABLE RECETA_INGREDIENTE(
                                   receta_ingrediente_id serial,
                                   fk_receta integer NOT NULL,
                                   fk_ingrediente integer NOT NULL,
                                   constraint pk_receta_ingrediente_id primary key (receta_ingrediente_id),
                                   constraint fk_receta_receta_ingrediente foreign key (fk_receta) references RECETA(receta_id),
                                   constraint fk_ingrediente_receta_ingrediente foreign key (fk_ingrediente) references INGREDIENTE(ingrediente_id)
);

CREATE TABLE MIEMBRO_ACAUCAB(
                                miembro_id serial,
                                razon_social varchar(100) NOT NULL,
                                denominacion_comercial varchar(100) NOT NULL,
                                RIF varchar(12) NOT NULL,
                                direccion varchar(255) NOT NULL,
                                direccion_fiscal varchar(255) NOT NULL,
                                pagina_web varchar(255) NOT NULL,
                                fk_lugar integer NOT NULL,
                                fk_lugar_fiscal integer NOT NULL,
                                constraint pk_miembro_id primary key (miembro_id),
                                constraint fk_lugar_miembro_acaucab foreign key (fk_lugar) references LUGAR(lugar_id),
                                constraint fk_lugar_fiscal_miembro_acaucab foreign key (fk_lugar_fiscal) references LUGAR(lugar_id)
);

CREATE TABLE CERVEZA(
                        cerveza_id serial,
                        nombre varchar(50) NOT NULL,
                        densidad_inicial NUMERIC(4,3) NOT NULL,
                        densidad_final NUMERIC(4,3) NOT NULL,
                        IBUs NUMERIC(3) NOT NULL,
                        nivel_alcohol NUMERIC(5,2) NOT NULL,
                        fk_tipo_cerveza integer NOT NULL,
                        fk_estilo_cerveza integer NOT NULL,
                        fk_receta integer NOT NULL,
                        constraint pk_cerveza_id primary key (cerveza_id),
                        constraint check_IBUs_cerveza check ( IBUs between 0 and 100),
                        constraint check_nivel_alcohol_cerveza check ( nivel_alcohol between 0 and 100),
                        constraint fk_receta_cerveza foreign key (fk_receta) references RECETA(receta_id),
                        constraint fk_estilo_cerveza_cerveza foreign key (fk_estilo_cerveza) references ESTILO_CERVEZA(estilo_cerveza_id),
                        constraint fk_tipo_cerveza_cerveza foreign key (fk_tipo_cerveza) references TIPO_CERVEZA(tipo_cerveza_id)
);

CREATE TABLE CERVEZA_PRESENTACION(
                                     cerveza_presentacion_id serial,
                                     fk_presentacion integer NOT NULL,
                                     fk_cerveza integer NOT NULL,
                                     fk_miembro_acaucab integer NOT NULL,
                                     constraint fk_presentacion_cerveza_presentacion foreign key (fk_presentacion) references PRESENTACION(presentacion_id),
                                     constraint fk_cerveza_cerveza_presentacion foreign key (fk_cerveza) references CERVEZA(cerveza_id),
                                     constraint pk_cerveza_presentacion_id primary key (cerveza_presentacion_id),
                                     constraint fk_miembro_acaucab_cerveza_presentacion foreign key (fk_miembro_acaucab) references MIEMBRO_ACAUCAB(miembro_id)
);

CREATE TABLE OFERTA(
                       oferta_id serial,
                       fecha_inicio DATE NOT NULL,
                       fecha_fin DATE NOT NULL,
                       descuento NUMERIC(3) NOT NULL,
                       fk_cerveza_presentacion integer NOT NULL,
                       constraint pk_oferta_id primary key (oferta_id),
                       constraint fk_cerveza_presentacion_oferta foreign key (fk_cerveza_presentacion) references CERVEZA_PRESENTACION(cerveza_presentacion_id),
                       constraint check_descuento_oferta check ( descuento between 0 and 100)
);

CREATE TABLE EVENTO_MIEMBRO_ACAUCAB(
                                       evento_miembro_acaucab_id serial,
                                       fk_evento integer NOT NULL,
                                       fk_miembro_acaucab integer NOT NULL,
                                       fk_cerveza_presentacion integer NOT NULL,
                                       cantidad integer NOT NULL,
                                       constraint fk_evento_evento_miembro_acaucab foreign key (fk_evento) references EVENTO(evento_id),
                                       constraint fk_miembro_acaucab_evento_miembro_acaucab foreign key (fk_miembro_acaucab) references MIEMBRO_ACAUCAB(miembro_id),
                                       constraint fk_cerveza_presentacion_evento_miembro_acaucab foreign key (fk_cerveza_presentacion) references CERVEZA_PRESENTACION(cerveza_presentacion_id),
                                       constraint pk_evento_miembro_acaucab_id primary key (evento_miembro_acaucab_id)
);

CREATE TABLE PREMIACION_EVENTO_MIEMBRO(
                                          premiacion_evento_miembro_id serial,
                                          fk_evento_miembro_acaucab integer NOT NULL,
                                          fk_premiacion_evento integer NOT NULL,
                                          constraint fk_evento_miembro_acaucab_premiacion_evento_miembro foreign key (fk_evento_miembro_acaucab) references EVENTO_MIEMBRO_ACAUCAB(evento_miembro_acaucab_id),
                                          constraint fk_premiacion_evento_premiacion_evento_miembro foreign key (fk_premiacion_evento) references PREMIACION_EVENTO(premiacion_evento_id),
                                          constraint pk_premiacion_evento_miembro_id primary key (premiacion_evento_miembro_id)
);

CREATE TABLE PREMIO(
                       premio_id serial,
                       nombre varchar(50) NOT NULL,
                       fecha DATE NOT NULL,
                       fk_premiacion_evento_miembro integer NOT NULL,
                       constraint pk_premio_id primary key (premio_id),
                       constraint fk_premiacion_evento_miembro_premio foreign key (fk_premiacion_evento_miembro) references PREMIACION_EVENTO_MIEMBRO(premiacion_evento_miembro_id)
);

CREATE TABLE TIPO_CERVEZA_CARACTERISTICA(
                                            tipo_cerveza_caracteristica_id serial,
                                            fk_tipo_cerveza integer NOT NULL,
                                            fk_caracteristica integer NOT NULL,
                                            constraint pk_tipo_cerveza_caracteristica_id primary key (tipo_cerveza_caracteristica_id),
                                            constraint fk_tipo_cerveza_tipo_cerveza_caracteristica foreign key (fk_tipo_cerveza) references TIPO_CERVEZA(tipo_cerveza_id),
                                            constraint fk_caracteristica_tipo_cerveza_caracteristica foreign key (fk_caracteristica) references CARACTERISTICA(caracteristica_id)
);

CREATE TABLE CERVEZA_CARACTERISTICA(
                                       cerveza_caracteristica_id serial,
                                       fk_cerveza integer NOT NULL,
                                       fk_caracteristica integer NOT NULL,
                                       constraint pk_cerveza_caracteristica_id primary key (cerveza_caracteristica_id),
                                       constraint fk_cerveza_cerveza_caracteristica foreign key (fk_cerveza) references CERVEZA(cerveza_id),
                                       constraint fk_caracteristica_cerveza_caracteristica foreign key (fk_caracteristica) references CARACTERISTICA(caracteristica_id)
);

CREATE TABLE ALMACEN_CERVEZA(
                                almacen_cerveza_id serial,
                                fk_almacen integer NOT NULL,
                                fk_cerveza_presentacion integer NOT NULL,
                                cantidad integer NOT NULL,
                                fecha DATE NOT NULL,
                                precio_unitario integer NOT NULL,
                                constraint pk_almacen_cerveza_id primary key (almacen_cerveza_id),
                                constraint fk_almacen_almacen_cerveza foreign key (fk_almacen) references ALMACEN(almacen_id),
                                constraint fk_cerveza_presentacion_almacen_cerveza foreign key (fk_cerveza_presentacion) references CERVEZA_PRESENTACION(cerveza_presentacion_id)
);

CREATE TABLE ANAQUEL_CERVEZA(
                                anaquel_cerveza_id serial,
                                fk_anaquel integer NOT NULL,
                                fk_cerveza_presentacion integer NOT NULL,
                                cantidad integer NOT NULL,
                                fecha DATE NOT NULL,
                                precio_unitario integer NOT NULL,
                                constraint pk_anaquel_cerveza_id primary key (anaquel_cerveza_id),
                                constraint fk_anaquel_anaquel_cerveza foreign key (fk_anaquel) references ANAQUEL(anaquel_id),
                                constraint fk_cerveza_presentacion_anaquel_cerveza foreign key (fk_cerveza_presentacion) references CERVEZA_PRESENTACION(cerveza_presentacion_id)
);

CREATE TABLE DETALLE_REPOSICION_ANAQUEL(
                                           detalle_reposicion_anaquel_id serial,
                                           cantidad integer NOT NULL,
                                           precio_unitario integer NOT NULL,
                                           fk_almacen_cerveza integer NOT NULL,
                                           fk_reposicion_anaquel integer NOT NULL,
                                           fk_anaquel_cerveza integer NOT NULL,
                                           constraint pk_detalle_reposicion_anaquel_id primary key (detalle_reposicion_anaquel_id),
                                           constraint fk_reposicion_anaquel_detalle_reposicion_anaquel foreign key (fk_reposicion_anaquel) references REPOSICION_ANAQUEL(reposicion_anaquel_id),
                                           constraint fk_almacen_cerveza_detalle_reposicion_anaquel foreign key (fk_almacen_cerveza) references ALMACEN_CERVEZA(almacen_cerveza_id),
                                           constraint fk_anaquel_cerveza_detalle_reposicion_anaquel foreign key (fk_anaquel_cerveza) references ANAQUEL_CERVEZA(anaquel_cerveza_id)
);

CREATE TABLE CLIENTE_NATURAL(
                                cliente_id serial,
                                RIF varchar(12) NOT NULL unique,
                                direccion varchar(255) NOT NULL,
                                primer_nombre varchar(50) NOT NULL,
                                primer_apellido varchar(50) NOT NULL,
                                cedula integer NOT NULL unique,
                                segundo_nombre varchar(50),
                                segundo_apellido varchar(50),
                                total_puntos integer NOT NULL,
                                fk_lugar integer NOT NULL,
                                constraint pk_cliente_natural_id primary key (cliente_id),
                                constraint fk_lugar_cliente_natural foreign key (fk_lugar) references LUGAR(lugar_id)
);

CREATE TABLE CLIENTE_JURIDICO(
                                 cliente_id serial,
                                 RIF varchar(12) NOT NULL unique,
                                 direccion varchar(255) NOT NULL,
                                 denominacion_comercial varchar(255) NOT NULL,
                                 razon_social varchar(255) NOT NULL,
                                 capital integer NOT NULL,
                                 pagina_web varchar(255),
                                 direccion_fiscal varchar(255),
                                 fk_lugar integer NOT NULL,
                                 total_puntos integer NOT NULL,
                                 fk_lugar_juridico integer NOT NULL,
                                 constraint pk_cliente_juridico_id primary key (cliente_id),
                                 constraint fk_lugar_cliente_juridico foreign key (fk_lugar) references LUGAR(lugar_id),
                                 constraint fk_lugar_juridico_cliente_juridico foreign key (fk_lugar_juridico) references LUGAR(lugar_id)
);

CREATE TABLE PERSONAL_CONTACTO(
                                  personal_contacto_id serial,
                                  primer_nombre varchar(50) NOT NULL,
                                  primer_apellido varchar(50) NOT NULL,
                                  fk_cliente_juridico integer,
                                  fk_miembro_acaucab integer,
                                  constraint pk_personal_contaco_id primary key (personal_contacto_id),
                                  constraint fk_miembro_acaucab_personal_contacto foreign key (fk_miembro_acaucab) references MIEMBRO_ACAUCAB(miembro_id),
                                  constraint fk_cliente_juridico_personal_contacto foreign key (fk_cliente_juridico) references CLIENTE_JURIDICO(cliente_id),
                                  constraint check_miembro_cliente_juridico_personal_contacto check ( (fk_cliente_juridico IS NOT NULL AND fk_miembro_acaucab IS NULL) OR (fk_cliente_juridico IS NULL AND fk_miembro_acaucab IS NOT NULL)  )
);

CREATE TABLE TELEFONO(
                         telefono_id serial,
                         codigo smallint NOT NULL,
                         numero bigint NOT NULL,
                         fk_cliente_natural integer,
                         fk_cliente_juridico integer,
                         fk_personal_contacto integer,
                         fk_miembro_acaucab integer,
                         constraint pk_telefono_id primary key (telefono_id),
                         constraint fk_cliente_natural_telefono foreign key (fk_cliente_natural) references  CLIENTE_NATURAL(cliente_id),
                         constraint fk_cliente_juridico_telefono foreign key (fk_cliente_juridico) references  CLIENTE_JURIDICO(cliente_id),
                         constraint fk_miembro_acaucab_telefono foreign key (fk_miembro_acaucab) references MIEMBRO_ACAUCAB(miembro_id),
                         constraint fk_personal_contacto_telefono foreign key (fk_personal_contacto) references PERSONAL_CONTACTO(personal_contacto_id),
                         constraint check_personal_cliente_miembro_telefono check ( (fk_personal_contacto IS NOT NULL AND fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                             AND fk_cliente_natural IS NULL) OR (fk_personal_contacto IS NULL AND fk_miembro_acaucab IS NOT NULL AND fk_cliente_juridico IS NULL
                             AND fk_cliente_natural IS NULL) OR (fk_personal_contacto IS NULL AND fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NOT NULL
                             AND fk_cliente_natural IS NULL) OR (fk_personal_contacto IS NULL AND fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                             AND fk_cliente_natural IS NOT NULL) )
);

CREATE TABLE CORREO_ELECTRONICO(
                                   correo_electronico_id serial,
                                   usuario varchar(64) NOT NULL,
                                   dominio varchar(255) NOT NULL,
                                   fk_cliente_natural integer,
                                   fk_cliente_juridico integer,
                                   fk_miembro_acaucab integer,
                                   constraint pk_correo_electronico_id primary key (correo_electronico_id),
                                   constraint fk_cliente_natural_correo_electronico foreign key (fk_cliente_natural) references  CLIENTE_NATURAL(cliente_id),
                                   constraint fk_cliente_juridico_telefono foreign key (fk_cliente_juridico) references  CLIENTE_JURIDICO(cliente_id),
                                   constraint fk_miembro_acaucab_telefono foreign key (fk_miembro_acaucab) references MIEMBRO_ACAUCAB(miembro_id),
                                   constraint check_cliente_miembro_correo_electronico check ( (fk_miembro_acaucab IS NOT NULL AND fk_cliente_juridico IS NULL
                                       AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NOT NULL
                                       AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                                       AND fk_cliente_natural IS NOT NULL)),
                                   constraint check_dominio_correo_electronico check ( dominio LIKE'@%')
);

CREATE TABLE EVENTO_CLIENTE(
                               evento_cliente_id serial,
                               fk_evento integer NOT NULL,
                               fk_cliente_natural integer,
                               fk_cliente_juridico integer,
                               constraint pk_evento_cliente_id primary key(evento_cliente_id),
                               constraint fk_evento_evento_cliente foreign key (fk_evento) references EVENTO(evento_id),
                               constraint fk_cliente_juridico_evento_cliente foreign key (fk_cliente_juridico) references CLIENTE_JURIDICO(cliente_id),
                               constraint fk_cliente_natural_evento_cliente foreign key (fk_cliente_natural) references CLIENTE_NATURAL(cliente_id),
                               constraint check_cliente_evento_cliente check ( (fk_cliente_juridico IS NULL AND fk_cliente_natural IS NOT NULL) OR (fk_cliente_juridico IS NOT NULL AND fk_cliente_natural IS NULL) )
);

CREATE TABLE USUARIO(
                        usuario_id serial,
                        fecha_creacion DATE NOT NULL,
                        nombre_usuario varchar(50) NOT NULL UNIQUE,
                        hash_contrasena varchar(50) NOT NULL,
                        fk_cliente_natural integer,
                        fk_cliente_juridico integer,
                        fk_miembro_acaucab integer,
                        fk_empleado integer,
                        constraint pk_usuario_id primary key (usuario_id),
                        constraint fk_cliente_natural_usuario foreign key (fk_cliente_natural) references CLIENTE_NATURAL(cliente_id),
                        constraint fk_cliente_juridico_usuario foreign key (fk_cliente_juridico) references  CLIENTE_JURIDICO(cliente_id),
                        constraint fk_empleado_usuario foreign key (fk_empleado) references EMPLEADO(empleado_id),
                        constraint fk_miembro_acaucab_usuario foreign key (fk_miembro_acaucab) references  MIEMBRO_ACAUCAB(miembro_id),
                        constraint check_empleado_cliente_miembro_usuario check ( (fk_empleado IS NOT NULL AND fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                            AND fk_cliente_natural IS NULL) OR (fk_empleado IS NULL AND fk_miembro_acaucab IS NOT NULL AND fk_cliente_juridico IS NULL
                            AND fk_cliente_natural IS NULL) OR (fk_empleado IS NULL AND fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NOT NULL
                            AND fk_cliente_natural IS NULL) OR (fk_empleado IS NULL AND fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                            AND fk_cliente_natural IS NOT NULL) )
);

CREATE TABLE ROL_USUARIO(
                            rol_usuario_id serial,
                            fk_rol integer NOT NULL,
                            fk_usuario integer NOT NULL,
                            fecha_inicio DATE NOT NULL,
                            fecha_fin DATE,
                            constraint pk_rol_usuario_id primary key (rol_usuario_id) ,
                            constraint fk_rol_rol_usuario foreign key (fk_rol) references ROL(rol_id) ON DELETE CASCADE,
                            constraint fk_usuario_rol_usuario foreign key (fk_usuario) references USUARIO(usuario_id) ON DELETE CASCADE
);

CREATE TABLE MEMBRESIA(
                          membresia_id serial,
                          fecha_adquisicion DATE NOT NULL,
                          fecha_vencimiento DATE NOT NULL,
                          monto integer NOT NULL,
                          fk_usuario integer,
                          constraint pk_membresia_id primary key (membresia_id),
                          constraint fk_usuario_membresia foreign key (fk_usuario) references USUARIO(usuario_id)
);

CREATE TABLE COMPRA_REPOSICION(
                                  compra_reposicion_id serial,
                                  fecha_emision DATE NOT NULL,
                                  fecha_entrega DATE,
                                  fecha_pago_estimada DATE,
                                  fecha_pago_real DATE,
                                  total integer NOT NULL,
                                  fk_miembro_acaucab integer NOT NULL,
                                  constraint pk_compra_reposicion_id primary key (compra_reposicion_id),
                                  constraint fk_miembro_acaucab_compra_reposicion foreign key (fk_miembro_acaucab) references MIEMBRO_ACAUCAB(miembro_id)
);

CREATE TABLE ESTADO_COMPRA_REPOSICION(
                                         estado_compra_reposicion_id serial,
                                         fecha_inicio DATE NOT NULL,
                                         fecha_fin DATE,
                                         fk_estado integer NOT NULL,
                                         fk_compra_reposicion integer NOT NULL,
                                         constraint pk_estado_compra_reposicion_id primary key (estado_compra_reposicion_id),
                                         constraint fk_estado_estado_compra_reposicion foreign key (fk_estado) references ESTADO(estado_id),
                                         constraint fk_compra_reposicion_estado_compra_reposicion foreign key (fk_compra_reposicion) references COMPRA_REPOSICION(compra_reposicion_id)
);

CREATE TABLE DETALLE_COMPRA(
                               detalle_compra_id serial,
                               fk_cerveza_presentacion integer NOT NULL,
                               fk_compra_reposicion integer NOT NULL,
                               precio_unitario integer NOT NULL,
                               cantidad integer NOT NULL,
                               constraint pk_detalle_compra_id primary key (detalle_compra_id),
                               constraint fk_cerveza_presentacion_detalle_compra foreign key (fk_cerveza_presentacion) references CERVEZA_PRESENTACION(cerveza_presentacion_id),
                               constraint fk_compra_reposicion_detalle_compra foreign key (fk_compra_reposicion) references COMPRA_REPOSICION(compra_reposicion_id)
);

CREATE TABLE VENTA_ONLINE(
                             venta_online_id serial,
                             direccion varchar(255) NOT NULL,
                             fecha_emision DATE NOT NULL,
                             fecha_estimada DATE NOT NULL,
                             fecha_entrega DATE,
                             total integer NOT NULL,
                             fk_lugar integer NOT NULL,
                             fk_usuario integer NOT NULL,
                             constraint fk_usuario_venta_online foreign key (fk_usuario) references USUARIO(usuario_id),
                             constraint pk_venta_online primary key (venta_online_id),
                             constraint fk_lugar_venta_online foreign key (fk_lugar) references LUGAR(lugar_id)
);

CREATE TABLE DETALLE_VENTA_ONLINE(
                                     detalle_venta_online_id serial,
                                     fk_almacen_cerveza integer NOT NULL,
                                     fk_venta_online integer NOT NULL,
                                     precio_unitario integer NOT NULL,
                                     cantidad integer NOT NULL,
                                     constraint pk_detalle_venta_online_id primary key (detalle_venta_online_id),
                                     constraint fk_almacen_cerveza_detalle_venta_online foreign key (fk_almacen_cerveza) references ALMACEN_CERVEZA(almacen_cerveza_id),
                                     constraint fk_venta_online_detalle_venta_online foreign key (fk_venta_online) references VENTA_ONLINE(venta_online_id)
);

CREATE TABLE ESTADO_VENTA_ONLINE(
                                    estado_venta_online_id serial,
                                    fecha_inicio DATE NOT NULL,
                                    fecha_fin DATE,
                                    fk_estado integer NOT NULL,
                                    fk_venta_online integer NOT NULL,
                                    constraint pk_estado_venta_online_id primary key (estado_venta_online_id),
                                    constraint fk_estado_estado_venta_online foreign key (fk_estado) references ESTADO(estado_id),
                                    constraint fk_venta_online_estado_venta_online foreign key (fk_venta_online) references VENTA_ONLINE(venta_online_id)
);

CREATE TABLE VENTA_EVENTO(
                             venta_evento_id serial,
                             total integer NOT NULL,
                             fecha DATE NOT NULL,
                             fk_evento_cliente integer NOT NULL,
                             fk_evento integer NOT NULL,
                             constraint pk_venta_evento_id primary key (venta_evento_id),
                             constraint fk_evento_venta_evento foreign key (fk_evento) references EVENTO(evento_id),
                             constraint fk_evento_cliente_venta_evento foreign key (fk_evento_cliente) references EVENTO_CLIENTE(evento_cliente_id)
);

CREATE TABLE DETALLE_VENTA_EVENTO(
                                     detalle_venta_evento_id serial,
                                     fk_evento_miembro_acaucab integer,
                                     fk_venta_evento integer NOT NULL,
                                     fk_evento_entrada integer,
                                     precio_unitario integer NOT NULL,
                                     cantidad integer NOT NULL,
                                     constraint pk_detalle_venta_evento_id primary key (detalle_venta_evento_id),
                                     constraint fk_evento_miembro_acaucab_detalle_venta_evento foreign key (fk_evento_miembro_acaucab) references EVENTO_MIEMBRO_ACAUCAB(evento_miembro_acaucab_id),
                                     constraint fk_venta_evento_acaucab_detalle_venta_evento foreign key (fk_venta_evento) references VENTA_EVENTO(venta_evento_id),
                                     constraint fk_evento_entrada_detalle_venta_evento foreign key (fk_evento_entrada) references EVENTO(evento_id),
                                     constraint check_entrada_miembro_detalle_venta_evento check ( (fk_evento_entrada IS NOT NULL AND fk_evento_miembro_acaucab IS NULL)
                                         OR (fk_evento_entrada IS NULL AND fk_evento_miembro_acaucab IS NOT NULL))
);

CREATE TABLE VENTA_TIENDA(
                             venta_tienda_id serial,
                             total integer NOT NULL,
                             fecha DATE NOT NULL,
                             fk_cliente_natual integer,
                             fk_cliente_juridico integer,
                             constraint pk_venta_tienda_id primary key (venta_tienda_id),
                             constraint fk_cliente_natural_venta_tienda foreign key (fk_cliente_natual) references CLIENTE_NATURAL(cliente_id),
                             constraint fk_cliente_juridico_venta_tienda foreign key (fk_cliente_juridico) references CLIENTE_JURIDICO(cliente_id),
                             constraint check_cliente_venta_tienda check ( (fk_cliente_natual IS NOT NULL AND fk_cliente_juridico IS NULL)
                                 OR (fk_cliente_natual IS NULL AND fk_cliente_juridico IS NOT NULL))
);

CREATE TABLE DETALLE_VENTA_TIENDA(
                                     detalle_venta_tienda_id serial,
                                     fk_venta_tienda integer NOT NULL,
                                     fk_anaquel_cerveza integer NOT NULL,
                                     precio_unitario integer NOT NULL,
                                     cantidad integer NOT NULL,
                                     constraint pk_detalle_venta_tienda_id primary key (detalle_venta_tienda_id),
                                     constraint fk_anaquel_cerveza_detalle_venta_tienda foreign key (fk_anaquel_cerveza) references ANAQUEL_CERVEZA(anaquel_cerveza_id),
                                     constraint fk_venta_tienda_detalle_venta_tienda foreign key (fk_venta_tienda) references VENTA_TIENDA(venta_tienda_id)
);

CREATE TABLE METODO_PAGO_EFECTIVO(
                                     metodo_pago_id serial,
                                     denominacion integer NOT NULL,
                                     fk_cliente_natural integer,
                                     fk_cliente_juridico integer,
                                     fk_miembro_acaucab integer,
                                     constraint pk_metodo_pago_efectivo_id primary key (metodo_pago_id),
                                     constraint check_cliente_miembro_metodo_pago_efectivo check ( (fk_miembro_acaucab IS NOT NULL AND fk_cliente_juridico IS NULL
                                         AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NOT NULL
                                         AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                                         AND fk_cliente_natural IS NOT NULL))
);

CREATE TABLE METODO_PAGO_DEBITO(
                                   metodo_pago_id serial,
                                   numero bigint NOT NULL,
                                   banco varchar(50) NOT NULL,
                                   fk_cliente_natural integer,
                                   fk_cliente_juridico integer,
                                   fk_miembro_acaucab integer,
                                   constraint pk_metodo_pago_debito_id primary key (metodo_pago_id),
                                   constraint check_cliente_miembro_metodo_pago_debito check ( (fk_miembro_acaucab IS NOT NULL AND fk_cliente_juridico IS NULL
                                       AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NOT NULL
                                       AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                                       AND fk_cliente_natural IS NOT NULL))
);

CREATE TABLE METODO_PAGO_CREDITO(
                                    metodo_pago_id serial,
                                    numero bigint NOT NULL,
                                    banco varchar(50) NOT NULL,
                                    fecha_exp DATE NOT NULL,
                                    fk_cliente_natural integer,
                                    fk_cliente_juridico integer,
                                    fk_miembro_acaucab integer,
                                    constraint pk_metodo_pago_credito_id primary key (metodo_pago_id),
                                    constraint check_cliente_miembro_metodo_pago_credito check ( (fk_miembro_acaucab IS NOT NULL AND fk_cliente_juridico IS NULL
                                        AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NOT NULL
                                        AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                                        AND fk_cliente_natural IS NOT NULL))
);

CREATE TABLE METODO_PAGO_CHEQUE(
                                   metodo_pago_id serial,
                                   numero integer NOT NULL,
                                   numero_c bigint NOT NULL,
                                   banco varchar(50) NOT NULL,
                                   fk_cliente_natural integer,
                                   fk_cliente_juridico integer,
                                   fk_miembro_acaucab integer,
                                   constraint pk_metodo_pago_cheque_id primary key (metodo_pago_id),
                                   constraint check_cliente_miembro_metodo_pago_cheque check ( (fk_miembro_acaucab IS NOT NULL AND fk_cliente_juridico IS NULL
                                       AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NOT NULL
                                       AND fk_cliente_natural IS NULL) OR (fk_miembro_acaucab IS NULL AND fk_cliente_juridico IS NULL
                                       AND fk_cliente_natural IS NOT NULL))
);

CREATE TABLE METODO_PAGO_PUNTO(
                                  metodo_pago_id serial,
                                  fk_cliente_natural integer,
                                  fk_cliente_juridico integer,
                                  constraint pk_metodo_pago_punto_id primary key (metodo_pago_id),
                                  constraint check_cliente_metodo_pago_punto check ( (fk_cliente_juridico IS NOT NULL
                                      AND fk_cliente_natural IS NULL) OR ( fk_cliente_juridico IS NULL
                                      AND fk_cliente_natural IS NOT NULL))
);

CREATE TABLE PUNTO_VENTA_COMPRA(
                                   punto_venta_compra_id serial,
                                   fk_venta_tienda integer,
                                   fk_venta_online integer,
                                   fk_cliente_natural integer,
                                   fk_cliente_juridico integer,
                                   fk_metodo_pago_punto integer,
                                   cantidad integer NOT NULL,
                                   fecha DATE NOT NULL,
                                   tipo varchar(11) NOT NULL,
                                   constraint pk_punto_venta_compra_id primary key (punto_venta_compra_id),
                                   constraint fk_venta_tienda_punto_venta_compra foreign key (fk_venta_tienda) references VENTA_TIENDA(venta_tienda_id),
                                   constraint fk_venta_online_punto_venta_compra foreign key (fk_venta_online) references VENTA_ONLINE(venta_online_id),
                                   constraint fk_metodo_pago_punto_punto_venta_compra foreign key (fk_metodo_pago_punto) references METODO_PAGO_PUNTO(metodo_pago_id),
                                   constraint fk_cliente_natural_punto_venta_compra foreign key (fk_cliente_natural) references CLIENTE_NATURAL(cliente_id),
                                   constraint fk_cliente_juridico_punto_venta_compra foreign key (fk_cliente_juridico) references CLIENTE_JURIDICO(cliente_id),
                                   constraint check_venta_punto_venta_compra check ( (fk_venta_online IS NULL AND fk_venta_tienda IS NOT NULL)
                                       OR (fk_venta_online IS NOT NULL AND fk_venta_tienda IS NULL) ),
                                   constraint check_cliente_punto_venta_compra check ( (fk_cliente_juridico IS NULL AND fk_cliente_natural IS NOT NULL)
                                       OR (fk_cliente_juridico IS NOT NULL AND fk_cliente_natural IS NULL) ),
                                   constraint check_tipo_punto_venta_compra check ( tipo IN('adquisicion','gasto') )
);

CREATE TABLE TASA_CONVERSION(
                                tasa_conversion_id serial,
                                fecha_inicio DATE NOT NULL,
                                tasa_puntos_a_bs integer NOT NULL,
                                tasa_dola_a_bs integer NOT NULL,
                                fecha_fin DATE,
                                fk_metodo_pago_punto integer,
                                fk_metodo_pago_efectivo integer,
                                constraint pk_tasa_conversion_id primary key (tasa_conversion_id),
                                constraint fk_metodo_pago_punto_tasa_conversion foreign key (fk_metodo_pago_punto) references METODO_PAGO_PUNTO(metodo_pago_id),
                                constraint fk_metodo_pago_efectivo_tasa_conversion foreign key (fk_metodo_pago_efectivo) references METODO_PAGO_EFECTIVO(metodo_pago_id),
                                constraint check_metodo_pago_tasa_conversion check ( (fk_metodo_pago_efectivo IS NOT NULL AND fk_metodo_pago_punto IS NULL) OR
                                                                                     (fk_metodo_pago_efectivo IS NULL AND fk_metodo_pago_punto IS NOT NULL))
);

CREATE TABLE PAGO(
                     pago_id serial,
                     monto integer NOT NULL,
                     fecha DATE NOT NULL,
                     fk_venta_online integer,
                     fk_venta_tienda integer,
                     fk_compra_reposicion integer,
                     fk_venta_evento integer,
                     fk_membresia integer,
                     fk_metodo_pago_efectivo integer,
                     fk_metodo_pago_cheque integer,
                     fk_metodo_pago_debito integer,
                     fk_metodo_pago_credito integer,
                     fk_metodo_pago_punto integer,
                     constraint pk_pago_id primary key (pago_id),
                     constraint fk_metodo_pago_punto_pago foreign key (fk_metodo_pago_punto) references METODO_PAGO_PUNTO(metodo_pago_id),
                     constraint fk_metodo_pago_cheque_pago foreign key (fk_metodo_pago_cheque) references METODO_PAGO_CHEQUE(metodo_pago_id),
                     constraint fk_metodo_pago_debito_pago foreign key (fk_metodo_pago_debito) references METODO_PAGO_DEBITO(metodo_pago_id),
                     constraint fk_metodo_pago_credito_pago foreign key (fk_metodo_pago_credito) references METODO_PAGO_CREDITO(metodo_pago_id),
                     constraint fk_metodo_pago_efectivo_pago foreign key (fk_metodo_pago_efectivo) references METODO_PAGO_EFECTIVO(metodo_pago_id),
                     constraint fk_venta_online_pago foreign key (fk_venta_online) references VENTA_ONLINE(venta_online_id),
                     constraint fk_venta_tienda_pago foreign key (fk_venta_tienda) references VENTA_TIENDA(venta_tienda_id),
                     constraint fk_venta_evento_pago foreign key (fk_venta_evento) references VENTA_EVENTO(venta_evento_id),
                     constraint fk_compra_reposicion_pago foreign key (fk_compra_reposicion) references COMPRA_REPOSICION(compra_reposicion_id),
                     constraint fk_membresia_pago foreign key (fk_membresia) references MEMBRESIA(membresia_id),
                     constraint check_metodo_pago_pago
                         check ((fk_metodo_pago_efectivo IS NOT NULL AND fk_metodo_pago_credito IS NULL AND fk_metodo_pago_debito IS NULL AND fk_metodo_pago_cheque IS NULL AND fk_metodo_pago_punto IS NULL)
                             OR (fk_metodo_pago_efectivo IS NULL AND fk_metodo_pago_credito IS NOT NULL AND fk_metodo_pago_debito IS NULL AND fk_metodo_pago_cheque IS NULL AND fk_metodo_pago_punto IS NULL)
                             OR (fk_metodo_pago_efectivo IS NULL AND fk_metodo_pago_credito IS NULL AND fk_metodo_pago_debito IS NOT NULL AND fk_metodo_pago_cheque IS NULL AND fk_metodo_pago_punto IS NULL)
                             OR (fk_metodo_pago_efectivo IS NULL AND fk_metodo_pago_credito IS NULL AND fk_metodo_pago_debito IS NULL AND fk_metodo_pago_cheque IS NOT NULL AND fk_metodo_pago_punto IS NULL)
                             OR (fk_metodo_pago_efectivo IS NULL AND fk_metodo_pago_credito IS NULL AND fk_metodo_pago_debito IS NULL AND fk_metodo_pago_cheque IS NULL AND fk_metodo_pago_punto IS NOT NULL)),
                     constraint check_venta_compra_pago
                         check ((fk_membresia IS NOT NULL AND fk_venta_online IS NULL AND fk_venta_tienda IS NULL AND fk_venta_evento IS NULL AND fk_compra_reposicion IS NULL)
                             OR (fk_membresia IS NULL AND fk_venta_online IS NOT NULL AND fk_venta_tienda IS NULL AND fk_venta_evento IS NULL AND fk_compra_reposicion IS NULL)
                             OR (fk_membresia IS NULL AND fk_venta_online IS NULL AND fk_venta_tienda IS NOT NULL AND fk_venta_evento IS NULL AND fk_compra_reposicion IS NULL)
                             OR (fk_membresia IS NULL AND fk_venta_online IS NULL AND fk_venta_tienda IS NULL AND fk_venta_evento IS NOT NULL AND fk_compra_reposicion IS NULL)
                             OR (fk_membresia IS NULL AND fk_venta_online IS NULL AND fk_venta_tienda IS NULL AND fk_venta_evento IS NULL AND fk_compra_reposicion IS NOT NULL))
);

CREATE PROCEDURE eliminarRol(id integer)
    LANGUAGE SQL
AS $$
DELETE FROM ROL WHERE rol_id=id;
$$;

CREATE PROCEDURE editarRol(id integer, nom varchar, des varchar)
    LANGUAGE SQL
AS $$
UPDATE ROL SET descripcion=des, nombre=nom where rol_id=id
$$;

CREATE PROCEDURE guardarRol(nom varchar, des varchar)
    LANGUAGE SQL
AS $$
INSERT INTO ROL (nombre,descripcion) VALUES (nom,des)
$$;

CREATE FUNCTION obtenerRoles()
    RETURNS SETOF ROL
    LANGUAGE SQL
AS $$
SELECT * FROM ROL;
$$;

CREATE FUNCTION obtenerPermisos()
    RETURNS SETOF PERMISO
    LANGUAGE SQL
AS $$
SELECT * FROM PERMISO where descripcion LIKE 'consultar%'
$$;

CREATE FUNCTION obtenerRolPermisos(rol integer)
    RETURNS TABLE(
                     permiso_id integer,
                     descripcion varchar(255),
                     rol_permiso_id integer,
                     fk_rol integer,
                     fk_permiso integer
                 )
    LANGUAGE SQL
AS $$
SELECT permiso_id, descripcion, rol_permiso_id, fk_rol, fk_permiso
FROM PERMISO,ROL_PERMISO
WHERE fk_rol=rol AND fk_permiso = permiso_id
$$;

CREATE FUNCTION obtenerUsuario(nom varchar,pass varchar)
    RETURNS TABLE(
                     cedula integer,
                     primer_nombre varchar(50),
                     segundo_nombre varchar(50),
                     segundo_apellido varchar(50),
                     primer_apellido varchar(50),
                     direccion varchar(255),
                     fecha_contrato text,
                     usuario_id integer,
                     nombre_usuario varchar(50),
                     nombre varchar(50)
                 )
    LANGUAGE SQL
AS $$
SELECT e.cedula,e.primer_nombre,e.segundo_nombre,e.segundo_apellido,e.primer_apellido,
       e.direccion, TO_CHAR(e.fecha_contrato, 'DD-MM-YYYY') as fecha_contrato, u.usuario_id, u.nombre_usuario, c.nombre
FROM DEPARTAMENTO_EMPLEADO de, CARGO c, EMPLEADO e,USUARIO u where u.nombre_usuario=nom AND
    u.hash_contrasena=pass AND e.empleado_id=u.fk_empleado AND e.empleado_id = de.fk_empleado AND  de.fk_cargo = c.cargo_id
$$;

CREATE FUNCTION obtenerPermisosUsuario(id integer)
    RETURNS TABLE(
                     descripcion varchar(50),
                     permiso_id integer
                 )
    LANGUAGE SQL
AS $$
SELECT p.descripcion,p.permiso_id FROM ROL_USUARIO ru, ROL r, ROL_PERMISO rp, PERMISO p  where
    ru.fk_usuario=id AND r.rol_id=ru.fk_rol AND rp.fk_rol=r.rol_id AND rp.fk_permiso=p.permiso_id
$$;

CREATE PROCEDURE insertarRolPermisos(
    p_rol_id INTEGER,
    p_permiso_descripciones TEXT[]
)
    LANGUAGE SQL
AS $$
INSERT INTO ROL_PERMISO (fk_rol, fk_permiso)
SELECT
    p_rol_id,
    P.permiso_id
FROM
    PERMISO AS P
        JOIN
    unnest(p_permiso_descripciones) AS DescripcionesArray(descripcion_unica)
    ON P.descripcion = DescripcionesArray.descripcion_unica;
$$;

CREATE FUNCTION reducirstock()
    RETURNS TRIGGER AS $$
BEGIN
    UPDATE anaquel_cerveza
    SET cantidad = cantidad - NEW.cantidad
    WHERE anaquel_cerveza_id = NEW.fk_anaquel_cerveza;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER triggerReducirStock
    after insert on detalle_venta_tienda
    for each row
execute FUNCTION reducirstock();

CREATE FUNCTION aumentarstock()
    RETURNS TRIGGER AS $$
    declare
        rep record;
BEGIN
    if new.fecha_entrega IS NOT NULL then
        for rep in select cantidad,fk_anaquel_cerveza from detalle_reposicion_anaquel
        where new.reposicion_anaquel_id=fk_reposicion_anaquel
    LOOP
    UPDATE anaquel_cerveza
    SET cantidad = cantidad + rep.cantidad
    WHERE anaquel_cerveza_id = rep.fk_anaquel_cerveza;
    END LOOP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER triggerAumentarStock
    after update on reposicion_anaquel
    for each row
execute procedure aumentarstock();

CREATE FUNCTION obtenerCervezas()
    RETURNS TABLE(
                     anaquel_cerveza_id integer,
                     cerveza_presentacion_id integer,
                     nombre varchar(50),
                     precio_unitario integer,
                     cap_volumen integer,
                     cantidad integer)
    language sql
AS
$$
SELECT ac.anaquel_cerveza_id, pc.cerveza_presentacion_id,c.nombre, ac.precio_unitario, p.cap_volumen, sum(ac.cantidad) as cantidad
FROM CERVEZA_PRESENTACION pc,CERVEZA c,PRESENTACION p, anaquel_cerveza ac
WHERE pc.fk_cerveza=c.cerveza_id AND p.presentacion_id=pc.fk_presentacion AND pc.cerveza_presentacion_id=ac.fk_cerveza_presentacion
GROUP BY pc.cerveza_presentacion_id, c.nombre, p.cap_volumen, ac.precio_unitario,ac.anaquel_cerveza_id;
$$;

CREATE PROCEDURE insertarNuevaTarjetaCliente(
    p_cliente_tipo varchar,
    p_cliente_id INTEGER,
    p_tipo VARCHAR,
    p_numero_tarjeta bigint DEFAULT NULL,
    p_fecha_vencimiento DATE DEFAULT NULL,
    p_banco VARCHAR(50) DEFAULT NULL
)
    LANGUAGE plpgsql
AS $$
BEGIN
    IF p_cliente_tipo = 'natural' then
        IF p_tipo = 'debito' THEN
            INSERT INTO metodo_pago_debito (numero, banco, fk_cliente_natural) VALUES (
                                                                                          p_numero_tarjeta,
                                                                                          p_banco,
                                                                                          p_cliente_id
                                                                                      );
        ELSIF p_tipo = 'credito' THEN
            INSERT INTO metodo_pago_credito (numero, fecha_exp, banco, fk_cliente_natural) VALUES (
                                                                                                      p_numero_tarjeta,
                                                                                                      p_fecha_vencimiento,
                                                                                                      p_banco,
                                                                                                      p_cliente_id
                                                                                                  );
        END IF;
    elsif p_cliente_tipo ='juridico' then
        IF p_tipo = 'debito' THEN
            INSERT INTO metodo_pago_debito (numero, banco, fk_cliente_juridico) VALUES (
                                                                                           p_numero_tarjeta,
                                                                                           p_banco,
                                                                                           p_cliente_id
                                                                                       );
        ELSIF p_tipo = 'credito' THEN
            INSERT INTO metodo_pago_credito (numero, fecha_exp, banco, fk_cliente_juridico) VALUES (
                                                                                                       p_numero_tarjeta,
                                                                                                       p_fecha_vencimiento,
                                                                                                       p_banco,
                                                                                                       p_cliente_id
                                                                                                   );
        END IF;
    End if;
END;
$$;

CREATE OR REPLACE FUNCTION buscarMetodosDePagoCliente(
    p_tipo_cliente VARCHAR,
    p_id INTEGER
)
    RETURNS TABLE(
                     metodo_pago_id INTEGER,
                     tipo CHARACTER VARYING,
                     numero BIGINT,
                     banco CHARACTER VARYING
                 )
    LANGUAGE plpgsql
AS $$
BEGIN
    IF p_tipo_cliente = 'natural' THEN
        RETURN QUERY
            SELECT mpc.metodo_pago_id, 'credito'::varchar, mpc.numero, mpc.banco
            FROM metodo_pago_credito mpc
            WHERE mpc.fk_cliente_natural = p_id

            UNION ALL

            SELECT mpd.metodo_pago_id, 'debito'::varchar, mpd.numero, mpd.banco
            FROM metodo_pago_debito mpd
            WHERE mpd.fk_cliente_natural = p_id;

    ELSIF p_tipo_cliente = 'juridico' THEN
        RETURN QUERY
            SELECT mpc.metodo_pago_id, 'credito'::varchar, mpc.numero, mpc.banco
            FROM metodo_pago_credito mpc
            WHERE mpc.fk_cliente_juridico = p_id

            UNION ALL

            SELECT mpd.metodo_pago_id, 'debito'::varchar, mpd.numero, mpd.banco
            FROM metodo_pago_debito mpd
            WHERE mpd.fk_cliente_juridico = p_id;
    END IF;

    RETURN;
END;
$$;


CREATE OR REPLACE PROCEDURE insertarVentaTiendaConDetalle(
    p_total INTEGER,
    p_cliente INTEGER,
    p_tipo varchar,
    p_detalles JSONB,
    p_metodos JSONB
)
    LANGUAGE plpgsql
AS $$
DECLARE
    v_venta_tienda_id INTEGER;
    detalle JSONB;
    metodos JSONB;
    p_punto_id integer;
    p_cheque_id integer;
    p_efectivo_id integer;
BEGIN
    if p_tipo = 'natural' then
        INSERT INTO VENTA_TIENDA (
            total,
            fecha,
            fk_cliente_natual
        ) VALUES (
                     p_total,
                     current_date,
                     p_cliente
                 )
        RETURNING venta_tienda_id INTO v_venta_tienda_id;
    elsif p_tipo='juridico' then
        INSERT INTO VENTA_TIENDA (
            total,
            fecha,
            fk_cliente_juridico
        ) VALUES (
                     p_total,
                     current_date,
                     p_cliente
                 )
        RETURNING venta_tienda_id INTO v_venta_tienda_id;
    END IF;

    -- Insert each detail item from the JSON array
    FOR detalle IN SELECT * FROM jsonb_array_elements(p_detalles)
        LOOP
            INSERT INTO DETALLE_VENTA_TIENDA (
                fk_venta_tienda,
                fk_anaquel_cerveza,
                precio_unitario,
                cantidad
            ) VALUES (
                         v_venta_tienda_id,
                         (detalle->>'id')::INTEGER,
                         (detalle->>'price')::INTEGER,
                         (detalle->>'quantity')::INTEGER
                     );
        END LOOP;

    FOR metodos IN SELECT * FROM jsonb_array_elements(p_metodos)
        LOOP
            IF (metodos->>'tipo')::varchar = 'cheque' then
                IF p_tipo='natural' then
                    INSERT INTO metodo_pago_cheque (numero, numero_c, banco, fk_cliente_natural)
                    VALUES (
                               (metodos->>'numero_cheque')::INTEGER,
                               (metodos->>'numero_cuenta')::BIGINT,
                               (metodos->>'banco')::varchar,
                               p_cliente
                           )
                    returning metodo_pago_id into p_cheque_id;
                    insert into pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_cheque)
                    values ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,p_cheque_id);
                ELSIF p_tipo='juridico' then
                    INSERT INTO metodo_pago_cheque (numero, numero_c, banco, fk_cliente_juridico)
                    VALUES (
                               (metodos->>'numero_cheque')::INTEGER,
                               (metodos->>'numero_cuenta')::BIGINT,
                               (metodos->>'banco')::varchar,
                               p_cliente
                           )
                    returning metodo_pago_id into p_cheque_id;
                    insert into pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_cheque)
                    values ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,p_cheque_id);

                END IF;
            END IF;
            IF (metodos->>'tipo')::varchar = 'efectivo'then
                IF p_tipo='natural' THEN
                    INSERT INTO metodo_pago_efectivo (denominacion, fk_cliente_natural)
                    VALUES (
                               1::INTEGER,
                               p_cliente
                           )
                    returning metodo_pago_id into p_efectivo_id;
                    insert into pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_efectivo)
                    values ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,p_efectivo_id);

                ELSIF p_tipo='juridico' then
                    INSERT INTO metodo_pago_efectivo (denominacion, fk_cliente_juridico)
                    VALUES (
                               1::INTEGER,
                               p_cliente
                           )
                    returning metodo_pago_id into p_efectivo_id;
                    insert into pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_efectivo)
                    values ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,p_efectivo_id);
                END IF;
            END IF;
            IF (metodos->>'tipo')::varchar = 'puntos' then
                IF p_tipo='natural' then
                    INSERT INTO metodo_pago_punto (fk_cliente_natural)
                    VALUES (
                               p_cliente
                           )
                    RETURNING metodo_pago_id INTO p_punto_id;
                    insert into punto_venta_compra (fk_venta_tienda, fk_cliente_natural, fk_metodo_pago_punto, cantidad, fecha, tipo)
                    values (v_venta_tienda_id,p_cliente,p_punto_id,
                            (metodos->>'cantidad')::INTEGER, current_date,'gasto');
                    insert into pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_punto) values
                        ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,p_punto_id);
                elseif p_tipo = 'juridico' then
                    INSERT INTO metodo_pago_punto (fk_cliente_juridico)
                    VALUES (
                               p_cliente
                           )
                    RETURNING metodo_pago_id INTO p_punto_id;
                    insert into punto_venta_compra (fk_venta_tienda, fk_cliente_juridico, fk_metodo_pago_punto, cantidad, fecha, tipo)
                    values (v_venta_tienda_id,p_cliente,p_punto_id,
                            (metodos->>'cantidad')::INTEGER, current_date,'gasto');
                    insert into pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_punto) values
                        ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,p_punto_id);
                END IF;
            END IF;
            IF (metodos->>'tipo')::varchar = 'debito' then
                INSERT INTO pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_debito)
                VALUES ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,(metodos->>'id')::INTEGER);
            END IF;
            IF (metodos->>'tipo')::varchar = 'credito' then
                INSERT INTO pago (monto, fecha, fk_venta_tienda, fk_metodo_pago_credito)
                VALUES ((metodos->>'cantidad')::INTEGER,current_date,v_venta_tienda_id,(metodos->>'id')::INTEGER);
            END IF;
        END LOOP;
    IF p_tipo = 'natural' then
        insert into punto_venta_compra (fk_venta_tienda, fk_cliente_natural, cantidad, fecha, tipo)
        values (v_venta_tienda_id,p_cliente,
                p_total, current_date,'adquisicion');
    elsif p_tipo = 'juridico' then
        insert into punto_venta_compra (fk_venta_tienda, fk_cliente_juridico, cantidad, fecha, tipo)
        values (v_venta_tienda_id,p_cliente,
                p_total, current_date,'adquisicion');
    END IF;
END;
$$;

create function ajustarPuntos() returns trigger
    language plpgsql
as
$$
BEGIN
    IF NEW.tipo = 'adquisicion' THEN
        IF NEW.fk_cliente_natural IS NULL THEN
            UPDATE cliente_juridico
            SET total_puntos = total_puntos + NEW.cantidad
            WHERE cliente_id = NEW.fk_cliente_juridico;
        ELSiF NEW.fk_cliente_juridico IS NULL THEN
            UPDATE cliente_natural
            SET total_puntos = total_puntos + NEW.cantidad
            WHERE cliente_id = NEW.fk_cliente_natural;
        END IF;
    ELSIF NEW.tipo = 'gasto' THEN
        IF NEW.fk_cliente_natural IS NULL THEN
            UPDATE cliente_juridico
            SET total_puntos = total_puntos - NEW.cantidad
            WHERE cliente_id = NEW.fk_cliente_juridico;
        ELSiF NEW.fk_cliente_juridico IS NULL THEN
            UPDATE cliente_natural
            SET total_puntos = total_puntos - NEW.cantidad
            WHERE cliente_id = NEW.fk_cliente_natural;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;

create trigger triggerajustarpuntos
    after insert
    on punto_venta_compra
    for each row
execute procedure ajustarpuntos();

create or replace function emitirordenreposicionanaquel()
    returns trigger
    language plpgsql
as
$$
declare
    orderid integer;
    almacenid integer;
    existe boolean;
    yapedido boolean;
begin

    if(NEW.cantidad) < 20 then
        select exists(
            select reposicion_anaquel_id from reposicion_anaquel, estado_reposicion_anaquel era where
                fecha_entrega is null and era.fk_reposicion_anaquel=reposicion_anaquel_id and
                era.fk_estado not in(4,5) and era.fecha_fin is null
            order by reposicion_anaquel_id desc
            limit 1
        ) into existe;

        IF NOT existe THEN
            INSERT INTO reposicion_anaquel (fecha)
            VALUES (CURRENT_DATE)
            RETURNING reposicion_anaquel_id INTO orderid;
            insert into estado_reposicion_anaquel (fecha_inicio, fecha_fin, fk_estado, fk_reposicion_anaquel)
            values (current_date,null,1,orderid);
        ELSE
            select reposicion_anaquel_id into orderid from reposicion_anaquel where
                fecha_entrega is null
            order by reposicion_anaquel_id desc
            limit 1;
        end if;

        select exists(
            select fk_anaquel_cerveza from detalle_reposicion_anaquel where
                fk_reposicion_anaquel = orderid AND fk_anaquel_cerveza = new.anaquel_cerveza_id
        ) into yapedido;

        IF NOT yapedido THEN
            select almacen_cerveza_id into almacenid
            from almacen_cerveza where fk_cerveza_presentacion = new.fk_cerveza_presentacion
            order by almacen_cerveza_id
            limit 1;

            insert into detalle_reposicion_anaquel (cantidad, precio_unitario, fk_almacen_cerveza, fk_reposicion_anaquel, fk_anaquel_cerveza)
            values (200,new.precio_unitario,almacenid,orderid,new.anaquel_cerveza_id);
        end if;

    END IF;
    return new;
end;
$$;

create trigger triggerEmitirOrdenReposicionAnaquel
    after update on anaquel_cerveza
    for each row
execute function emitirOrdenReposicionAnaquel();

create or replace function obtenerRolUsuario(id integer)
    returns table(rol_id integer, nombre varchar)
    language sql
as
    $$
        select rol.rol_id, rol.nombre from rol, rol_usuario where fk_usuario = id AND
        fk_rol=rol_id;
    $$;


CREATE OR REPLACE PROCEDURE insertarusuariorol(
    p_usuario_id INTEGER,
    p_roles_ids jsonb
)
    LANGUAGE plpgsql
AS $$
DECLARE
    rol_id jsonb;
BEGIN
    FOR rol_ID IN SELECT * FROM jsonb_array_elements(p_roles_ids)
        LOOP
            INSERT INTO rol_usuario(
                fk_rol,
                fk_usuario,
                fecha_inicio
            ) VALUES (
            (rol_id->>'rol_id')::INTEGER,
                         p_usuario_id,
                         CURRENT_DATE
                     );
        END LOOP;
END;
$$;

CREATE OR REPLACE FUNCTION reposicionAnaquelEntregado()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF new.fk_estado = 8 then
    UPDATE reposicion_anaquel set fecha_entrega = current_date
    where reposicion_anaquel_id = new.fk_reposicion_anaquel;
    end if;
    RETURN NEW;
END;
$$;

CREATE TRIGGER triggerReposicionAnaquelEntregado
    AFTER INSERT on estado_reposicion_anaquel
    FOR EACH ROW EXECUTE FUNCTION reposicionAnaquelEntregado();

CREATE OR REPLACE FUNCTION reducirStockAlmacen()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
    declare
        almacen_id integer;
BEGIN
    IF new.fk_estado = 8 then
        for almacen_id in (select fk_almacen_cerveza from
        detalle_reposicion_anaquel dra where dra.fk_reposicion_anaquel = new.fk_reposicion_anaquel)
        loop
        UPDATE almacen_cerveza set cantidad = cantidad -200
        where almacen_cerveza_id = almacen_id;
        end loop;
    end if;
    RETURN NEW;
END;
$$;

CREATE TRIGGER triggerReducirStockAlmacen
    AFTER INSERT on estado_reposicion_anaquel
    FOR EACH ROW EXECUTE FUNCTION reducirStockAlmacen();

create function emitircomprareposicion() returns trigger
    language plpgsql
as
$$
declare
    orderid integer;
    cantpedido integer;
    existe boolean;
begin

    if(NEW.cantidad) <= 100 then
        select exists(
            select compra_reposicion_id from compra_reposicion cr, estado_compra_reposicion ecr where
                cr.fecha_entrega is null AND cr.fk_miembro_acaucab = (select ma.miembro_id from miembro_acaucab ma, cerveza_presentacion pc
                                                                      where new.fk_cerveza_presentacion = pc.cerveza_presentacion_id
                                                                        AND pc.fk_miembro_acaucab = ma.miembro_id) and cr.compra_reposicion_id = ecr.fk_compra_reposicion
                                                                                                and ecr.fk_estado NOT IN(1,4,5) and ecr.fecha_fin is null
        ) into existe;

        IF NOT existe THEN
            INSERT INTO compra_reposicion (fecha_emision, fecha_entrega, fecha_pago_estimada, fecha_pago_real, total, fk_miembro_acaucab)
            VALUES (CURRENT_DATE,null,null,null,0,(select ma.miembro_id from miembro_acaucab ma,
                                                                             cerveza_presentacion pc
                                                   where new.fk_cerveza_presentacion = pc.cerveza_presentacion_id
                                                     AND pc.fk_miembro_acaucab = ma.miembro_id))
            RETURNING compra_reposicion_id INTO orderid;
            insert into estado_compra_reposicion (fecha_inicio, fecha_fin, fk_estado, fk_compra_reposicion)
            values (current_date,null,6,orderid);
        ELSE
            select compra_reposicion_id into orderid from compra_reposicion cr where
                cr.fecha_entrega is null AND cr.fk_miembro_acaucab = (select ma.miembro_id from miembro_acaucab ma, cerveza_presentacion pc
                                                                      where new.fk_cerveza_presentacion = pc.cerveza_presentacion_id
                                                                        AND pc.fk_miembro_acaucab = ma.miembro_id);
        end if;

        insert into detalle_compra (fk_cerveza_presentacion, fk_compra_reposicion, precio_unitario, cantidad)
        values (new.fk_cerveza_presentacion,orderid,new.precio_unitario,10000)
        RETURNING precio_unitario*10000 into cantpedido;

        update compra_reposicion set total = total + cantpedido*0.7
        where compra_reposicion_id = orderid;

    END IF;

    return new;
end;
$$;

create trigger triggerCompraReposicion
    after update on almacen_cerveza
    for each row
execute function emitirCompraReposicion();

CREATE OR REPLACE FUNCTION aumentarStockAlmacen()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
declare
    almacen_id integer;
BEGIN
    IF new.fk_estado = 8 then
        for almacen_id in (select almacen_cerveza_id from
            detalle_compra dc, almacen_cerveza ac where dc.fk_compra_reposicion = new.fk_compra_reposicion
            AND dc.fk_cerveza_presentacion = ac.fk_cerveza_presentacion)
            loop
                UPDATE almacen_cerveza set cantidad = cantidad +10000
                where almacen_cerveza_id = almacen_id;
            end loop;
    end if;
    RETURN NEW;
END;
$$;

CREATE TRIGGER triggerAumentarStockAlmacen
    AFTER insert on estado_compra_reposicion
    FOR EACH ROW EXECUTE FUNCTION aumentarStockAlmacen();


CREATE OR REPLACE FUNCTION reposicionAlmacenEntregado()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF new.fk_estado = 8 then
        UPDATE compra_reposicion set fecha_entrega = current_date,
        fecha_pago_estimada = current_date+15
        where compra_reposicion_id = new.fk_compra_reposicion;
    end if;
    RETURN NEW;
END;
$$;

CREATE TRIGGER triggerReposicionAlmacenEntregado
    AFTER insert on estado_compra_reposicion
    FOR EACH ROW EXECUTE FUNCTION reposicionAlmacenEntregado();

create or replace function obtenerordenesalmacen()
    returns TABLE(compra_reposicion_id integer, productos varchar, fecha_emision varchar, denominacion_comercial character varying, estado varchar, total integer)
    language sql
as
$$
SELECT  cr.compra_reposicion_id, string_agg(c.nombre||' '||p.cap_volumen::varchar||'ml', ', ') as productos, to_char(cr.fecha_emision,'DD-MM-YYYY'), ma.denominacion_comercial, e.nombre as estado, cr.total
    from compra_reposicion cr, cerveza_presentacion pc, miembro_acaucab ma, estado_compra_reposicion ecr, estado e,
         cerveza c, presentacion p, detalle_compra dc
    where cr.fk_miembro_acaucab = ma.miembro_id and dc.fk_compra_reposicion = cr.compra_reposicion_id and
          dc.fk_cerveza_presentacion = pc.cerveza_presentacion_id and c.cerveza_id = pc.fk_cerveza and
          p.presentacion_id = pc.fk_presentacion and ecr.fk_compra_reposicion = cr.compra_reposicion_id and ecr.fk_estado = e.estado_id
          and ecr.fecha_fin IS NULL
    group by cr.compra_reposicion_id, ma.denominacion_comercial, e.nombre, cr.fecha_emision, cr.total
$$;

create or replace procedure cambiarEstadoCompraRep(cambio varchar, id integer)
language plpgsql
as
    $$
    declare
        Nuevoestado_id integer;
    begin
        select into Nuevoestado_id e.estado_id from estado e
        where e.nombre=cambio;
        update estado_compra_reposicion set fecha_fin = current_date
        where fk_compra_reposicion=id;
        insert into estado_compra_reposicion (fecha_inicio, fecha_fin, fk_estado, fk_compra_reposicion)
        values (current_date,null,Nuevoestado_id,id);
    end;
    $$;


CREATE OR REPLACE FUNCTION get_stock_almacen()
RETURNS TABLE(
  cerveza_presentacion_id INT,
  nombre_cerveza TEXT,
  material TEXT,
  cap_volumen INT,
  cantidad INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cp.cerveza_presentacion_id::INT,
    c.nombre::TEXT,
    p.material::TEXT,
    p.cap_volumen::INT,
    COALESCE(SUM(ac.cantidad), 0)::INT
  FROM almacen_cerveza ac
  JOIN cerveza_presentacion cp ON ac.fk_cerveza_presentacion = cp.cerveza_presentacion_id
  JOIN cerveza c ON cp.fk_cerveza = c.cerveza_id
  JOIN presentacion p ON cp.fk_presentacion = p.presentacion_id
  GROUP BY cp.cerveza_presentacion_id, c.nombre, p.material, p.cap_volumen;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS get_stock_anaquel();

CREATE OR REPLACE FUNCTION get_stock_anaquel()
RETURNS TABLE(
  cerveza_presentacion_id INT,
  nombre_cerveza TEXT,
  material TEXT,
  cap_volumen INT,
  cantidad INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cp.cerveza_presentacion_id::INT,
    c.nombre::TEXT,
    p.material::TEXT,
    p.cap_volumen::INT,
    COALESCE(SUM(anac.cantidad), 0)::INT
  FROM anaquel_cerveza anac
  JOIN cerveza_presentacion cp ON anac.fk_cerveza_presentacion = cp.cerveza_presentacion_id
  JOIN cerveza c ON cp.fk_cerveza = c.cerveza_id
  JOIN presentacion p ON cp.fk_presentacion = p.presentacion_id
  GROUP BY cp.cerveza_presentacion_id, c.nombre, p.material, p.cap_volumen;
END;
$$ LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS get_stock_general();

CREATE OR REPLACE FUNCTION get_stock_general()
RETURNS TABLE(
  cerveza_presentacion_id INT,
  nombre_cerveza TEXT,
  material TEXT,
  cap_volumen INT,
  cantidad_total INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cp.cerveza_presentacion_id::INT,
    c.nombre::TEXT,
    p.material::TEXT,
    p.cap_volumen::INT,
    (COALESCE(SUM(ac.cantidad), 0) + COALESCE(SUM(anac.cantidad), 0))::INT AS cantidad_total
  FROM cerveza_presentacion cp
  LEFT JOIN almacen_cerveza ac ON cp.cerveza_presentacion_id = ac.fk_cerveza_presentacion
  LEFT JOIN anaquel_cerveza anac ON cp.cerveza_presentacion_id = anac.fk_cerveza_presentacion
  JOIN cerveza c ON cp.fk_cerveza = c.cerveza_id
  JOIN presentacion p ON cp.fk_presentacion = p.presentacion_id
  GROUP BY cp.cerveza_presentacion_id, c.nombre, p.material, p.cap_volumen;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION get_productos_mas_vendidos(
    fecha_inicio DATE,
    fecha_fin DATE,
    limite INTEGER
)
RETURNS TABLE (
    producto_id INT,
    nombre_producto TEXT,
    presentacion_ml INT,
    tipo_presentacion TEXT,
    total_ventas INT,
    unidades_vendidas INT,
    precio_promedio NUMERIC,
    ingresos_totales NUMERIC,
    precio_promedio_ponderado NUMERIC,
    clientes_unicos INT,
    primera_venta DATE,
    ultima_venta DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.cerveza_id::INT,
        c.nombre::TEXT,
        p.cap_volumen::INT,
        p.material::TEXT,
        COUNT(DISTINCT vo.venta_online_id)::INT,
        SUM(dvo.cantidad)::INT,
        ROUND(AVG(dvo.precio_unitario), 2)::NUMERIC,
        SUM(dvo.cantidad * dvo.precio_unitario)::NUMERIC,
        ROUND(SUM(dvo.cantidad * dvo.precio_unitario) / NULLIF(SUM(dvo.cantidad),0), 2)::NUMERIC,
        COUNT(DISTINCT vo.fk_usuario)::INT,
        MIN(vo.fecha_emision)::DATE,
        MAX(vo.fecha_emision)::DATE
    FROM cerveza c
    JOIN cerveza_presentacion cp ON c.cerveza_id = cp.fk_cerveza
    JOIN presentacion p ON cp.fk_presentacion = p.presentacion_id
    JOIN almacen_cerveza ac ON cp.cerveza_presentacion_id = ac.fk_cerveza_presentacion
    JOIN detalle_venta_online dvo ON ac.almacen_cerveza_id = dvo.fk_almacen_cerveza
    JOIN venta_online vo ON dvo.fk_venta_online = vo.venta_online_id
    WHERE 
        (
            (fecha_inicio IS NULL AND fecha_fin IS NULL)
            OR
            (vo.fecha_emision BETWEEN fecha_inicio AND fecha_fin)
        )
    GROUP BY c.cerveza_id, c.nombre, p.cap_volumen, p.material
    ORDER BY SUM(dvo.cantidad) DESC, SUM(dvo.cantidad * dvo.precio_unitario) DESC
    LIMIT limite;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_reposicion_anaqueles(
  p_fecha_inicio DATE DEFAULT NULL,
  p_fecha_fin DATE DEFAULT NULL,
  p_limite INTEGER DEFAULT 100
)
RETURNS TABLE (
  reposicion_anaquel_id INTEGER,
  fecha DATE,
  producto_nombre VARCHAR,
  presentacion VARCHAR,
  CANTIDAD_SOLICITADA INTEGER,
  pasillo VARCHAR,
  anaquel VARCHAR,
  estado VARCHAR,
  stock_actual INTEGER,
  prioridad VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  IF p_fecha_inicio IS NOT NULL AND p_fecha_fin IS NOT NULL THEN
    RETURN QUERY
    SELECT
      ra.reposicion_anaquel_id,
      ra.fecha,
      c.nombre AS producto_nombre,
      (pr.material || ' ' || pr.cap_volumen || 'ml')::VARCHAR AS presentacion,
      dra.cantidad AS CANTIDAD_SOLICITADA,
      pas.nombre AS pasillo,
      anq.anaquel_id::VARCHAR AS anaquel,
      e.nombre AS estado,
      ac.cantidad AS stock_actual,
      CASE 
        WHEN ac.cantidad < 10 THEN 'CRÍTICA'
        WHEN ac.cantidad < 20 THEN 'ALTA'
        WHEN ac.cantidad < 50 THEN 'MEDIA'
        ELSE 'BAJA'
      END::VARCHAR AS prioridad
    FROM reposicion_anaquel ra
    JOIN detalle_reposicion_anaquel dra ON dra.fk_reposicion_anaquel = ra.reposicion_anaquel_id
    JOIN anaquel_cerveza ac ON dra.fk_anaquel_cerveza = ac.anaquel_cerveza_id
    JOIN anaquel anq ON ac.fk_anaquel = anq.anaquel_id
    JOIN pasillo pas ON anq.fk_pasillo = pas.pasillo_id
    JOIN cerveza_presentacion cp ON ac.fk_cerveza_presentacion = cp.cerveza_presentacion_id
    JOIN cerveza c ON cp.fk_cerveza = c.cerveza_id
    JOIN presentacion pr ON cp.fk_presentacion = pr.presentacion_id
    JOIN estado_reposicion_anaquel era ON era.fk_reposicion_anaquel = ra.reposicion_anaquel_id AND era.fecha_fin IS NULL
    JOIN estado e ON era.fk_estado = e.estado_id
    WHERE ra.fecha BETWEEN p_fecha_inicio AND p_fecha_fin
      AND e.nombre != 'Completado'  -- Excluir órdenes completadas
    ORDER BY 
      CASE 
        WHEN e.nombre IN ('Pendiente', 'En Proceso') THEN 1
        WHEN e.nombre = 'Recibido' THEN 2
        ELSE 3
      END,
      ra.fecha DESC,
      ac.cantidad ASC
    LIMIT p_limite;
  ELSE
    RETURN QUERY
    SELECT
      ra.reposicion_anaquel_id,
      ra.fecha,
      c.nombre AS producto_nombre,
      (pr.material || ' ' || pr.cap_volumen || 'ml')::VARCHAR AS presentacion,
      dra.cantidad AS CANTIDAD_SOLICITADA,
      pas.nombre AS pasillo,
      anq.anaquel_id::VARCHAR AS anaquel,
      e.nombre AS estado,
      ac.cantidad AS stock_actual,
      CASE 
        WHEN ac.cantidad < 10 THEN 'CRÍTICA'
        WHEN ac.cantidad < 20 THEN 'ALTA'
        WHEN ac.cantidad < 50 THEN 'MEDIA'
        ELSE 'BAJA'
      END::VARCHAR AS prioridad
    FROM reposicion_anaquel ra
    JOIN detalle_reposicion_anaquel dra ON dra.fk_reposicion_anaquel = ra.reposicion_anaquel_id
    JOIN anaquel_cerveza ac ON dra.fk_anaquel_cerveza = ac.anaquel_cerveza_id
    JOIN anaquel anq ON ac.fk_anaquel = anq.anaquel_id
    JOIN pasillo pas ON anq.fk_pasillo = pas.pasillo_id
    JOIN cerveza_presentacion cp ON ac.fk_cerveza_presentacion = cp.cerveza_presentacion_id
    JOIN cerveza c ON cp.fk_cerveza = c.cerveza_id
    JOIN presentacion pr ON cp.fk_presentacion = pr.presentacion_id
    JOIN estado_reposicion_anaquel era ON era.fk_reposicion_anaquel = ra.reposicion_anaquel_id AND era.fecha_fin IS NULL
    JOIN estado e ON era.fk_estado = e.estado_id
    WHERE e.nombre != 'Completado'  -- Excluir órdenes completadas
    ORDER BY 
      CASE 
        WHEN e.nombre IN ('Pendiente', 'En Proceso') THEN 1
        WHEN e.nombre = 'Recibido' THEN 2
        ELSE 3
      END,
      ra.fecha DESC,
      ac.cantidad ASC
    LIMIT p_limite;
  END IF;
END;
$$;

create or replace function getTasaDolar()
returns table(tasa integer)
    language sql
as
$$
select tasa_dola_a_bs as tasa from tasa_conversion where
fecha_fin is null
limit 1
$$;

create or replace function obtenerordenesanaquel()
    returns TABLE(reposicion_anaquel_id integer, fecha varchar, productos varchar,estado varchar)
    language sql
as
$$
SELECT ra.reposicion_anaquel_id, to_char(ra.fecha,'DD-MM-YYYY') as productos, string_agg(c.nombre||' '||p.cap_volumen::varchar||'ml', ', ') as productos, e.nombre
FROM reposicion_anaquel ra, estado_reposicion_anaquel era, anaquel_cerveza ac, cerveza_presentacion pc, cerveza c,
     presentacion p, estado e, detalle_reposicion_anaquel dra
where ra.reposicion_anaquel_id = era.fk_reposicion_anaquel and era.fk_estado = e.estado_id and dra.fk_reposicion_anaquel = ra.reposicion_anaquel_id
    and dra.fk_anaquel_cerveza = ac.anaquel_cerveza_id and pc.cerveza_presentacion_id = ac.fk_cerveza_presentacion and
        p.presentacion_id = pc.fk_presentacion and pc.fk_cerveza = c.cerveza_id and era.fecha_fin is null
    group by ra.reposicion_anaquel_id, ra.fecha, e.nombre
$$;

CREATE OR REPLACE FUNCTION get_clientes_juridicos()
RETURNS TABLE(
    cliente_id integer,
    razon_social varchar,
    denominacion_comercial varchar,
    rif varchar,
    capital integer,
    direccion varchar,
    total_puntos integer,
    total_compras integer,
    monto_total_compras numeric
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cj.cliente_id,
    cj.razon_social,
    cj.denominacion_comercial,
    cj.rif,
    cj.capital,
    cj.direccion,
    cj.total_puntos,
    COUNT(DISTINCT vo.venta_online_id)::integer as total_compras,
    COALESCE(SUM(vo.total), 0)::numeric as monto_total_compras
  FROM cliente_juridico cj
  LEFT JOIN usuario u ON cj.cliente_id = u.fk_cliente_juridico
  LEFT JOIN venta_online vo ON u.usuario_id = vo.fk_usuario
  GROUP BY
    cj.cliente_id,
    cj.razon_social,
    cj.denominacion_comercial,
    cj.rif,
    cj.capital,
    cj.direccion,
    cj.total_puntos
  ORDER BY
    cj.razon_social;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_cuotas_afiliacion_pendientes(
  p_fecha_inicio DATE DEFAULT NULL,
  p_fecha_fin DATE DEFAULT NULL,
  p_limite INTEGER DEFAULT 1000
)
RETURNS TABLE (
  miembro_id INTEGER,
  razon_social VARCHAR,
  rif VARCHAR,
  fecha_afiliacion DATE,
  cuota_mensual INTEGER,
  fecha_vencimiento DATE,
  estado_afiliacion VARCHAR,
  ultimo_pago_fecha DATE,
  ultimo_pago_monto INTEGER,
  meses_pendientes INTEGER,
  monto_pendiente INTEGER,
  monto_total_pagado INTEGER,
  deuda_final INTEGER,
  contacto_nombre VARCHAR,
  contacto_telefono VARCHAR,
  contacto_email VARCHAR,
  direccion VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  WITH calculos_membresia AS (
    SELECT 
      ma.miembro_id,
      ma.razon_social,
      ma.rif,
      u.fecha_creacion as fecha_afiliacion,
      mem.monto::INTEGER as cuota_mensual,
      mem.fecha_vencimiento,
      CASE 
        WHEN mem.fecha_vencimiento >= CURRENT_DATE THEN 'ACTIVO'
        ELSE 'VENCIDO'
      END::VARCHAR as estado_afiliacion,
      MAX(p.fecha) FILTER (WHERE p.fk_membresia IS NOT NULL) as ultimo_pago_fecha,
      MAX(p.monto) FILTER (WHERE p.fk_membresia IS NOT NULL)::INTEGER as ultimo_pago_monto,
      COALESCE(SUM(p.monto) FILTER (WHERE p.fk_membresia IS NOT NULL), 0)::INTEGER as monto_total_pagado,
      CONCAT(pc.primer_nombre, ' ', pc.primer_apellido)::VARCHAR as contacto_nombre,
      CONCAT(t.codigo, '-', t.numero)::VARCHAR as contacto_telefono,
      CONCAT(ce.usuario, '@', ce.dominio)::VARCHAR as contacto_email,
      ma.direccion,
      -- Cálculo preciso de meses pendientes
      CASE 
        WHEN mem.fecha_vencimiento >= CURRENT_DATE THEN 
          -- Para activos: meses desde afiliación hasta hoy
          GREATEST(0, (DATE '2025-06-26' - u.fecha_creacion) / 30)
        ELSE 
          -- Para vencidos: meses desde afiliación hasta vencimiento
          GREATEST(0, (mem.fecha_vencimiento - u.fecha_creacion) / 30)
      END::INTEGER as meses_pendientes
    FROM miembro_acaucab ma
    INNER JOIN usuario u ON ma.miembro_id = u.fk_miembro_acaucab
    INNER JOIN membresia mem ON u.usuario_id = mem.fk_usuario
    LEFT JOIN pago p ON mem.membresia_id = p.fk_membresia
    LEFT JOIN personal_contacto pc ON ma.miembro_id = pc.fk_miembro_acaucab
    LEFT JOIN telefono t ON ma.miembro_id = t.fk_miembro_acaucab
    LEFT JOIN correo_electronico ce ON ma.miembro_id = ce.fk_miembro_acaucab
    WHERE ma.miembro_id IS NOT NULL
      AND (p_fecha_inicio IS NULL OR u.fecha_creacion >= p_fecha_inicio)
      AND (p_fecha_fin IS NULL OR u.fecha_creacion <= p_fecha_fin)
    GROUP BY 
      ma.miembro_id, ma.razon_social, ma.rif, ma.direccion, 
      u.fecha_creacion, mem.fecha_vencimiento, mem.monto, pc.primer_nombre, pc.primer_apellido,
      t.codigo, t.numero, ce.usuario, ce.dominio
  )
  SELECT 
    cm.miembro_id,
    cm.razon_social,
    cm.rif,
    cm.fecha_afiliacion,
    cm.cuota_mensual,
    cm.fecha_vencimiento,
    cm.estado_afiliacion,
    cm.ultimo_pago_fecha,
    cm.ultimo_pago_monto,
    cm.meses_pendientes,
    (cm.cuota_mensual * cm.meses_pendientes)::INTEGER as monto_pendiente,
    cm.monto_total_pagado,
    (cm.cuota_mensual * cm.meses_pendientes - cm.monto_total_pagado)::INTEGER as deuda_final,
    cm.contacto_nombre,
    cm.contacto_telefono,
    cm.contacto_email,
    cm.direccion
  FROM calculos_membresia cm
  WHERE 
    cm.meses_pendientes > 0 
    AND (cm.cuota_mensual * cm.meses_pendientes - cm.monto_total_pagado) > 0
  ORDER BY deuda_final DESC, meses_pendientes DESC
  LIMIT p_limite;
END;
$$;

CREATE OR REPLACE FUNCTION get_empleados()
RETURNS TABLE (
  id TEXT,
  cedula INTEGER,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  segundo_nombre VARCHAR,
  segundo_apellido VARCHAR,
  direccion VARCHAR,
  fecha_contrato DATE,
  fk_lugar INTEGER,
  nombre_completo VARCHAR,
  nombre_completo_full VARCHAR,
  tiene_usuario BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    empleado_id::TEXT as id,
    cedula,
    primer_nombre,
    primer_apellido,
    segundo_nombre,
    segundo_apellido,
    direccion,
    fecha_contrato,
    fk_lugar,
    CONCAT(primer_nombre, ' ', primer_apellido)::VARCHAR as nombre_completo,
    CONCAT(primer_nombre, ' ', COALESCE(segundo_nombre, ''), ' ', primer_apellido, ' ', COALESCE(segundo_apellido, ''))::VARCHAR as nombre_completo_full,
    CASE WHEN u.usuario_id IS NOT NULL THEN TRUE ELSE FALSE END as tiene_usuario
  FROM empleado e
  LEFT JOIN usuario u ON e.empleado_id = u.fk_empleado
  ORDER BY primer_nombre, primer_apellido;
END;
$$;


-- 1. Obtener todos los usuarios con empleados
CREATE OR REPLACE FUNCTION get_all_usuarios_with_empleados()
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  empleado_id TEXT,
  fk_cliente_natural INTEGER,
  fk_cliente_juridico INTEGER,
  fk_miembro_acaucab INTEGER,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  cedula INTEGER,
  empleado_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    u.fk_cliente_natural, 
    u.fk_cliente_juridico, 
    u.fk_miembro_acaucab,
    e.primer_nombre,
    e.primer_apellido,
    e.cedula,
    CONCAT(e.primer_nombre, ' ', e.primer_apellido)::VARCHAR as empleado_nombre
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  ORDER BY u.usuario_id;
END;
$$;

-- 2. Obtener usuario por ID
CREATE OR REPLACE FUNCTION get_usuario_with_empleado_by_id(p_id INTEGER)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  empleado_id TEXT,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  cedula INTEGER,
  empleado_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    e.primer_nombre,
    e.primer_apellido,
    e.cedula,
    CONCAT(e.primer_nombre, ' ', e.primer_apellido)::VARCHAR as empleado_nombre
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  WHERE u.usuario_id = p_id;
END;
$$;

-- 3. Obtener usuario por email
CREATE OR REPLACE FUNCTION get_usuario_with_empleado_by_email(p_email VARCHAR)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  empleado_id TEXT,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  cedula INTEGER,
  empleado_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    e.primer_nombre,
    e.primer_apellido,
    e.cedula,
    CONCAT(e.primer_nombre, ' ', e.primer_apellido)::VARCHAR as empleado_nombre
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  WHERE u.nombre_usuario = p_email;
END;
$$;

-- 6. Eliminar usuario por ID
CREATE OR REPLACE FUNCTION delete_usuario_by_id(p_id INTEGER)
RETURNS TABLE (
  id TEXT,
  email VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar si el usuario existe
  IF NOT EXISTS (SELECT 1 FROM usuario WHERE usuario_id = p_id) THEN
    RAISE EXCEPTION 'Usuario no encontrado';
  END IF;

  -- Eliminar usuario y retornar información
  RETURN QUERY
  DELETE FROM usuario
  WHERE usuario_id = p_id 
  RETURNING usuario_id::TEXT as id, nombre_usuario as email;
END;
$$;

-- ===== STORED PROCEDURES PARA GESTIÓN DE USUARIOS =====

-- Obtener TODOS los clientes naturales (para debugging)
CREATE OR REPLACE FUNCTION get_all_clientes_naturales()
RETURNS TABLE (
  id TEXT,
  cedula INTEGER,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  segundo_nombre VARCHAR,
  segundo_apellido VARCHAR,
  direccion VARCHAR,
  rif VARCHAR,
  total_puntos INTEGER,
  nombre_completo VARCHAR,
  nombre_completo_full VARCHAR,
  tiene_usuario BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cn.cliente_id::TEXT as id,
    cn.cedula,
    cn.primer_nombre,
    cn.primer_apellido,
    cn.segundo_nombre,
    cn.segundo_apellido,
    cn.direccion,
    cn.rif,
    cn.total_puntos,
    CONCAT(cn.primer_nombre, ' ', cn.primer_apellido)::VARCHAR as nombre_completo,
    CONCAT(cn.primer_nombre, ' ', COALESCE(cn.segundo_nombre, ''), ' ', cn.primer_apellido, ' ', COALESCE(cn.segundo_apellido, ''))::VARCHAR as nombre_completo_full,
    CASE WHEN u.usuario_id IS NOT NULL THEN TRUE ELSE FALSE END as tiene_usuario
  FROM cliente_natural cn
  LEFT JOIN usuario u ON cn.cliente_id = u.fk_cliente_natural
  ORDER BY cn.primer_nombre, cn.primer_apellido;
END;
$$;

-- Obtener TODOS los clientes jurídicos (para debugging)
CREATE OR REPLACE FUNCTION get_all_clientes_juridicos()
RETURNS TABLE (
  id TEXT,
  rif VARCHAR,
  razon_social VARCHAR,
  denominacion_comercial VARCHAR,
  capital integer,
  direccion VARCHAR,
  total_puntos INTEGER,
  nombre_completo VARCHAR,
  nombre_completo_full VARCHAR,
  tiene_usuario BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cj.cliente_id::TEXT as id,
    cj.rif,
    cj.razon_social,
    cj.denominacion_comercial,
    cj.capital,
    cj.direccion,
    cj.total_puntos,
    cj.razon_social as nombre_completo,
    cj.razon_social as nombre_completo_full,
    CASE WHEN u.usuario_id IS NOT NULL THEN TRUE ELSE FALSE END as tiene_usuario
  FROM cliente_juridico cj
  LEFT JOIN usuario u ON cj.cliente_id = u.fk_cliente_juridico
  ORDER BY cj.razon_social;
END;
$$;

-- Obtener TODOS los miembros ACAUCAB (para debugging)
CREATE OR REPLACE FUNCTION get_all_miembros_acaucab()
RETURNS TABLE (
  id TEXT,
  rif VARCHAR,
  razon_social VARCHAR,
  denominacion_comercial VARCHAR,
  direccion VARCHAR,
  nombre_completo VARCHAR,
  nombre_completo_full VARCHAR,
  tiene_usuario BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ma.miembro_id::TEXT as id,
    ma.rif,
    ma.razon_social,
    ma.denominacion_comercial,
    ma.direccion,
    ma.razon_social as nombre_completo,
    ma.razon_social as nombre_completo_full,
    CASE WHEN u.usuario_id IS NOT NULL THEN TRUE ELSE FALSE END as tiene_usuario
  FROM miembro_acaucab ma
  LEFT JOIN usuario u ON ma.miembro_id = u.fk_miembro_acaucab
  ORDER BY ma.razon_social;
END;
$$;

create function create_usuario_with_empleado(p_email character varying, p_password character varying, p_empleado_id integer)
    returns TABLE(id text, email character varying, fecha_creacion date, empleado_id text, primer_nombre character varying, primer_apellido character varying, cedula integer, empleado_nombre character varying)
    language plpgsql
as
$$
BEGIN
  -- Verificar que el empleado existe
  IF NOT EXISTS (SELECT 1 FROM empleado e WHERE e.empleado_id = p_empleado_id) THEN
    RAISE EXCEPTION 'El empleado seleccionado no existe';
  END IF;

  -- Verificar que el email no esté registrado
  IF EXISTS (SELECT 1 FROM usuario WHERE nombre_usuario = p_email) THEN
    RAISE EXCEPTION 'El email ya está registrado';
  END IF;
  -- Insertar usuario
  INSERT INTO usuario (nombre_usuario, hash_contrasena, fk_empleado, fecha_creacion)
  VALUES (p_email, p_password, p_empleado_id, CURRENT_DATE);

  -- Retornar información completa
  RETURN QUERY
  SELECT
    u.usuario_id::TEXT as id,
    u.nombre_usuario as email,
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    e.primer_nombre,
    e.primer_apellido,
    e.cedula,
    CONCAT(e.primer_nombre, ' ', e.primer_apellido)::VARCHAR as empleado_nombre
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  WHERE u.nombre_usuario = p_email;
END;
$$;


-- Crear usuario con cliente natural
CREATE OR REPLACE FUNCTION create_usuario_with_cliente_natural(
  p_email VARCHAR,
  p_password VARCHAR,
  p_cliente_natural_id INTEGER
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  cliente_natural_id TEXT,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  cedula INTEGER,
  cliente_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar que el cliente natural existe
  IF NOT EXISTS (SELECT 1 FROM cliente_natural WHERE cliente_id = p_cliente_natural_id) THEN
    RAISE EXCEPTION 'El cliente natural seleccionado no existe';
  END IF;

  -- Verificar que el email no esté registrado
  IF EXISTS (SELECT 1 FROM usuario WHERE nombre_usuario = p_email) THEN
    RAISE EXCEPTION 'El email ya está registrado';
  END IF;

  -- Verificar que el cliente no tenga usuario asignado
  IF EXISTS (SELECT 1 FROM usuario WHERE fk_cliente_natural = p_cliente_natural_id) THEN
    RAISE EXCEPTION 'El cliente natural ya tiene un usuario asignado';
  END IF;

  -- Insertar usuario
  INSERT INTO usuario (nombre_usuario, hash_contrasena, fk_cliente_natural, fecha_creacion)
  VALUES (p_email, p_password, p_cliente_natural_id, CURRENT_DATE);

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_cliente_natural::TEXT as cliente_natural_id,
    cn.primer_nombre,
    cn.primer_apellido,
    cn.cedula,
    CONCAT(cn.primer_nombre, ' ', cn.primer_apellido)::VARCHAR as cliente_nombre
  FROM usuario u
  LEFT JOIN cliente_natural cn ON u.fk_cliente_natural = cn.cliente_id
  WHERE u.nombre_usuario = p_email;
END;
$$;

-- Crear usuario con cliente jurídico
CREATE OR REPLACE FUNCTION create_usuario_with_cliente_juridico(
  p_email VARCHAR,
  p_password VARCHAR,
  p_cliente_juridico_id INTEGER
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  cliente_juridico_id TEXT,
  razon_social VARCHAR,
  rif VARCHAR,
  cliente_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar que el cliente jurídico existe
  IF NOT EXISTS (SELECT 1 FROM cliente_juridico WHERE cliente_id = p_cliente_juridico_id) THEN
    RAISE EXCEPTION 'El cliente jurídico seleccionado no existe';
  END IF;

  -- Verificar que el email no esté registrado
  IF EXISTS (SELECT 1 FROM usuario WHERE nombre_usuario = p_email) THEN
    RAISE EXCEPTION 'El email ya está registrado';
  END IF;
  -- Insertar usuario
  INSERT INTO usuario (nombre_usuario, hash_contrasena, fk_cliente_juridico, fecha_creacion)
  VALUES (p_email, p_password, p_cliente_juridico_id, CURRENT_DATE);

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_cliente_juridico::TEXT as cliente_juridico_id,
    cj.razon_social,
    cj.rif,
    cj.razon_social as cliente_nombre
  FROM usuario u
  LEFT JOIN cliente_juridico cj ON u.fk_cliente_juridico = cj.cliente_id
  WHERE u.nombre_usuario = p_email;
END;
$$;

-- Crear usuario con miembro ACAUCAB
CREATE OR REPLACE FUNCTION create_usuario_with_miembro_acaucab(
  p_email VARCHAR,
  p_password VARCHAR,
  p_miembro_acaucab_id INTEGER
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  miembro_acaucab_id TEXT,
  razon_social VARCHAR,
  rif VARCHAR,
  miembro_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar que el miembro ACAUCAB existe
  IF NOT EXISTS (SELECT 1 FROM miembro_acaucab WHERE miembro_id = p_miembro_acaucab_id) THEN
    RAISE EXCEPTION 'El miembro ACAUCAB seleccionado no existe';
  END IF;

  -- Verificar que el email no esté registrado
  IF EXISTS (SELECT 1 FROM usuario WHERE nombre_usuario = p_email) THEN
    RAISE EXCEPTION 'El email ya está registrado';
  END IF;

  -- Insertar usuario (permitir múltiples usuarios por miembro ACAUCAB)
  INSERT INTO usuario (nombre_usuario, hash_contrasena, fk_miembro_acaucab, fecha_creacion)
  VALUES (p_email, p_password, p_miembro_acaucab_id, CURRENT_DATE);

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_miembro_acaucab::TEXT as miembro_acaucab_id,
    ma.razon_social,
    ma.rif,
    ma.razon_social as miembro_nombre
  FROM usuario u
  LEFT JOIN miembro_acaucab ma ON u.fk_miembro_acaucab = ma.miembro_id
  WHERE u.nombre_usuario = p_email;
END;
$$;

-- ===== STORED PROCEDURES PARA ACTUALIZAR USUARIOS =====

-- Actualizar usuario con empleado
CREATE OR REPLACE FUNCTION update_usuario_with_empleado(
  p_id INTEGER,
  p_email VARCHAR,
  p_password VARCHAR DEFAULT NULL,
  p_empleado_id INTEGER DEFAULT NULL
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  empleado_id TEXT,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  empleado_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar si el usuario existe
  IF NOT EXISTS (SELECT 1 FROM usuario WHERE usuario_id = p_id) THEN
    RAISE EXCEPTION 'Usuario no encontrado';
  END IF;

  -- Si se proporciona empleadoId, verificar que existe
  IF p_empleado_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM empleado WHERE empleado_id = p_empleado_id) THEN
    RAISE EXCEPTION 'El empleado seleccionado no existe';
  END IF;

  -- Actualizar usuario
  IF p_password IS NOT NULL AND p_empleado_id IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      hash_contrasena = p_password, 
      fk_empleado = p_empleado_id,
      fk_cliente_natural = NULL,
      fk_cliente_juridico = NULL,
      fk_miembro_acaucab = NULL
    WHERE usuario_id = p_id;
  ELSIF p_password IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      hash_contrasena = p_password 
    WHERE usuario_id = p_id;
  ELSIF p_empleado_id IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      fk_empleado = p_empleado_id,
      fk_cliente_natural = NULL,
      fk_cliente_juridico = NULL,
      fk_miembro_acaucab = NULL
    WHERE usuario_id = p_id;
  ELSE
    UPDATE usuario SET nombre_usuario = p_email WHERE usuario_id = p_id;
  END IF;

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    e.primer_nombre,
    e.primer_apellido,
    CONCAT(e.primer_nombre, ' ', e.primer_apellido)::VARCHAR as empleado_nombre
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  WHERE u.usuario_id = p_id;
END;
$$;

-- Actualizar usuario con cliente natural
CREATE OR REPLACE FUNCTION update_usuario_with_cliente_natural(
  p_id INTEGER,
  p_email VARCHAR,
  p_password VARCHAR DEFAULT NULL
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  cliente_natural_id TEXT,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  cedula INTEGER,
  cliente_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar si el usuario existe
  IF NOT EXISTS (SELECT 1 FROM usuario WHERE usuario_id = p_id) THEN
    RAISE EXCEPTION 'Usuario no encontrado';
  END IF;

  -- Actualizar solo email y password (no cambiar la entidad)
  IF p_password IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      hash_contrasena = p_password
    WHERE usuario_id = p_id;
  ELSE
    UPDATE usuario SET nombre_usuario = p_email WHERE usuario_id = p_id;
  END IF;

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_cliente_natural::TEXT as cliente_natural_id,
    cn.primer_nombre,
    cn.primer_apellido,
    cn.cedula,
    CONCAT(cn.primer_nombre, ' ', cn.primer_apellido)::VARCHAR as cliente_nombre
  FROM usuario u
  LEFT JOIN cliente_natural cn ON u.fk_cliente_natural = cn.cliente_id
  WHERE u.usuario_id = p_id;
END;
$$;

-- Actualizar usuario con cliente jurídico
CREATE OR REPLACE FUNCTION update_usuario_with_cliente_juridico(
  p_id INTEGER,
  p_email VARCHAR,
  p_password VARCHAR DEFAULT NULL
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  cliente_juridico_id TEXT,
  razon_social VARCHAR,
  rif VARCHAR,
  cliente_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar si el usuario existe
  IF NOT EXISTS (SELECT 1 FROM usuario WHERE usuario_id = p_id) THEN
    RAISE EXCEPTION 'Usuario no encontrado';
  END IF;

  -- Actualizar solo email y password (no cambiar la entidad)
  IF p_password IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      hash_contrasena = p_password
    WHERE usuario_id = p_id;
  ELSE
    UPDATE usuario SET nombre_usuario = p_email WHERE usuario_id = p_id;
  END IF;

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_cliente_juridico::TEXT as cliente_juridico_id,
    cj.razon_social,
    cj.rif,
    cj.razon_social as cliente_nombre
  FROM usuario u
  LEFT JOIN cliente_juridico cj ON u.fk_cliente_juridico = cj.cliente_id
  WHERE u.usuario_id = p_id;
END;
$$;

-- Actualizar usuario con miembro ACAUCAB
CREATE OR REPLACE FUNCTION update_usuario_with_miembro_acaucab(
  p_id INTEGER,
  p_email VARCHAR,
  p_password VARCHAR DEFAULT NULL
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  miembro_acaucab_id TEXT,
  razon_social VARCHAR,
  rif VARCHAR,
  miembro_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar si el usuario existe
  IF NOT EXISTS (SELECT 1 FROM usuario WHERE usuario_id = p_id) THEN
    RAISE EXCEPTION 'Usuario no encontrado';
  END IF;

  -- Actualizar solo email y password (no cambiar la entidad)
  IF p_password IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      hash_contrasena = p_password
    WHERE usuario_id = p_id;
  ELSE
    UPDATE usuario SET nombre_usuario = p_email WHERE usuario_id = p_id;
  END IF;

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_miembro_acaucab::TEXT as miembro_acaucab_id,
    ma.razon_social,
    ma.rif,
    ma.razon_social as miembro_nombre
  FROM usuario u
  LEFT JOIN miembro_acaucab ma ON u.fk_miembro_acaucab = ma.miembro_id
  WHERE u.usuario_id = p_id;
END;
$$;

-- ===== STORED PROCEDURE PARA OBTENER TODOS LOS USUARIOS =====

-- Obtener todos los usuarios con información completa
CREATE OR REPLACE FUNCTION get_all_usuarios_complete()
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  empleado_id TEXT,
  fk_cliente_natural INTEGER,
  fk_cliente_juridico INTEGER,
  fk_miembro_acaucab INTEGER,
  -- Información del empleado
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  cedula INTEGER,
  empleado_nombre VARCHAR,
  -- Información del cliente natural
  cliente_natural_nombre VARCHAR,
  cliente_natural_apellido VARCHAR,
  cliente_natural_cedula INTEGER,
  cliente_natural_nombre_completo VARCHAR,
  -- Información del cliente jurídico
  cliente_juridico_nombre VARCHAR,
  cliente_juridico_rif VARCHAR,
  -- Información del miembro ACAUCAB
  miembro_acaucab_nombre VARCHAR,
  miembro_acaucab_rif VARCHAR,
  -- Campo combinado para mostrar la entidad asociada
  entidad_asociada VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    u.fk_cliente_natural, 
    u.fk_cliente_juridico, 
    u.fk_miembro_acaucab,
    -- Información del empleado
    e.primer_nombre,
    e.primer_apellido,
    e.cedula,
    CONCAT(e.primer_nombre, ' ', e.primer_apellido)::VARCHAR as empleado_nombre,
    -- Información del cliente natural
    cn.primer_nombre as cliente_natural_nombre,
    cn.primer_apellido as cliente_natural_apellido,
    cn.cedula as cliente_natural_cedula,
    CONCAT(cn.primer_nombre, ' ', cn.primer_apellido)::VARCHAR as cliente_natural_nombre_completo,
    -- Información del cliente jurídico
    cj.razon_social as cliente_juridico_nombre,
    cj.rif as cliente_juridico_rif,
    -- Información del miembro ACAUCAB
    ma.razon_social as miembro_acaucab_nombre,
    ma.rif as miembro_acaucab_rif,
    -- Campo combinado para mostrar la entidad asociada
    CASE 
      WHEN u.fk_empleado IS NOT NULL THEN CONCAT('Empleado: ', e.primer_nombre, ' ', e.primer_apellido, ' (Cédula: ', e.cedula, ')')
      WHEN u.fk_cliente_natural IS NOT NULL THEN CONCAT('Cliente Natural: ', cn.primer_nombre, ' ', cn.primer_apellido, ' (Cédula: ', cn.cedula, ')')
      WHEN u.fk_cliente_juridico IS NOT NULL THEN CONCAT('Cliente Jurídico: ', cj.razon_social, ' (RIF: ', cj.rif, ')')
      WHEN u.fk_miembro_acaucab IS NOT NULL THEN CONCAT('Miembro ACAUCAB: ', ma.razon_social, ' (RIF: ', ma.rif, ')')
      ELSE 'Sin entidad asociada'
    END::VARCHAR as entidad_asociada
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  LEFT JOIN cliente_natural cn ON u.fk_cliente_natural = cn.cliente_id
  LEFT JOIN cliente_juridico cj ON u.fk_cliente_juridico = cj.cliente_id
  LEFT JOIN miembro_acaucab ma ON u.fk_miembro_acaucab = ma.miembro_id
  ORDER BY u.usuario_id;
END;
$$;

-- Actualizar usuario con empleado
CREATE OR REPLACE FUNCTION update_usuario_with_empleado(
  p_id INTEGER,
  p_email VARCHAR,
  p_password VARCHAR DEFAULT NULL
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  empleado_id TEXT,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  empleado_nombre VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verificar si el usuario existe
  IF NOT EXISTS (SELECT 1 FROM usuario WHERE usuario_id = p_id) THEN
    RAISE EXCEPTION 'Usuario no encontrado';
  END IF;

  -- Actualizar solo email y password (no cambiar la entidad)
  IF p_password IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      hash_contrasena = p_password
    WHERE usuario_id = p_id;
  ELSE
    UPDATE usuario SET nombre_usuario = p_email WHERE usuario_id = p_id;
  END IF;

  -- Retornar información completa
  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    e.primer_nombre,
    e.primer_apellido,
    CONCAT(e.primer_nombre, ' ', e.primer_apellido)::VARCHAR as empleado_nombre
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  WHERE u.usuario_id = p_id;
END;
$$;


CREATE OR REPLACE FUNCTION update_usuario_with_entidad(
  p_id INTEGER,
  p_email VARCHAR,
  p_password VARCHAR DEFAULT NULL
)
RETURNS TABLE (
  id TEXT,
  email VARCHAR,
  fecha_creacion DATE,
  empleado_id TEXT,
  cliente_natural_id TEXT,
  cliente_juridico_id TEXT,
  miembro_acaucab_id TEXT,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  cedula INTEGER,
  razon_social VARCHAR,
  rif VARCHAR,
  entidad_asociada VARCHAR
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_fk_empleado INTEGER;
  v_fk_cliente_natural INTEGER;
  v_fk_cliente_juridico INTEGER;
  v_fk_miembro_acaucab INTEGER;
BEGIN
  SELECT u.fk_empleado, u.fk_cliente_natural, u.fk_cliente_juridico, u.fk_miembro_acaucab
  INTO v_fk_empleado, v_fk_cliente_natural, v_fk_cliente_juridico, v_fk_miembro_acaucab
  FROM usuario u WHERE u.usuario_id = p_id;

  IF p_password IS NOT NULL THEN
    UPDATE usuario SET 
      nombre_usuario = p_email, 
      hash_contrasena = p_password
    WHERE usuario_id = p_id;
  ELSE
    UPDATE usuario SET nombre_usuario = p_email WHERE usuario_id = p_id;
  END IF;

  RETURN QUERY
  SELECT 
    u.usuario_id::TEXT as id, 
    u.nombre_usuario as email, 
    u.fecha_creacion,
    u.fk_empleado::TEXT as empleado_id,
    u.fk_cliente_natural::TEXT as cliente_natural_id,
    u.fk_cliente_juridico::TEXT as cliente_juridico_id,
    u.fk_miembro_acaucab::TEXT as miembro_acaucab_id,
    e.primer_nombre,
    e.primer_apellido,
    e.cedula,
    cj.razon_social,
    cj.rif,
    CASE 
      WHEN u.fk_empleado IS NOT NULL THEN CONCAT('Empleado: ', e.primer_nombre, ' ', e.primer_apellido)::VARCHAR
      WHEN u.fk_cliente_natural IS NOT NULL THEN CONCAT('Cliente Natural: ', cn.primer_nombre, ' ', cn.primer_apellido)::VARCHAR
      WHEN u.fk_cliente_juridico IS NOT NULL THEN CONCAT('Cliente Jurídico: ', cj.razon_social, ' (RIF: ', cj.rif, ')')::VARCHAR
      WHEN u.fk_miembro_acaucab IS NOT NULL THEN CONCAT('Miembro ACAUCAB: ', ma.razon_social, ' (RIF: ', ma.rif, ')')::VARCHAR
      ELSE NULL::VARCHAR
    END as entidad_asociada
  FROM usuario u
  LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
  LEFT JOIN cliente_natural cn ON u.fk_cliente_natural = cn.cliente_id
  LEFT JOIN cliente_juridico cj ON u.fk_cliente_juridico = cj.cliente_id
  LEFT JOIN miembro_acaucab ma ON u.fk_miembro_acaucab = ma.miembro_id
  WHERE u.usuario_id = p_id;
END;
$$;

-- Obtener clientes naturales sin usuarios asignados
CREATE OR REPLACE FUNCTION get_clientes_naturales_sin_usuario()
RETURNS TABLE (
  id TEXT,
  cedula INTEGER,
  primer_nombre VARCHAR,
  primer_apellido VARCHAR,
  segundo_nombre VARCHAR,
  segundo_apellido VARCHAR,
  direccion VARCHAR,
  rif VARCHAR,
  total_puntos INTEGER,
  nombre_completo VARCHAR,
  nombre_completo_full VARCHAR,
  tiene_usuario BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cn.cliente_id::TEXT as id,
    cn.cedula,
    cn.primer_nombre,
    cn.primer_apellido,
    cn.segundo_nombre,
    cn.segundo_apellido,
    cn.direccion,
    cn.rif,
    cn.total_puntos,
    CONCAT(cn.primer_nombre, ' ', cn.primer_apellido)::VARCHAR as nombre_completo,
    CONCAT(cn.primer_nombre, ' ', COALESCE(cn.segundo_nombre, ''), ' ', cn.primer_apellido, ' ', COALESCE(cn.segundo_apellido, ''))::VARCHAR as nombre_completo_full,
    CASE WHEN u.usuario_id IS NOT NULL THEN TRUE ELSE FALSE END as tiene_usuario
  FROM cliente_natural cn
  LEFT JOIN usuario u ON cn.cliente_id = u.fk_cliente_natural
  ORDER BY cn.primer_nombre, cn.primer_apellido;
END;
$$;

-- Obtener miembros ACAUCAB sin usuarios asignados
CREATE OR REPLACE FUNCTION get_miembros_acaucab_sin_usuario()
RETURNS TABLE (
  id TEXT,
  rif VARCHAR,
  razon_social VARCHAR,
  denominacion_comercial VARCHAR,
  direccion VARCHAR,
  nombre_completo VARCHAR,
  nombre_completo_full VARCHAR,
  tiene_usuario BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ma.miembro_id::TEXT as id,
    ma.rif,
    ma.razon_social,
    ma.denominacion_comercial,
    ma.direccion,
    ma.razon_social as nombre_completo,
    ma.razon_social as nombre_completo_full,
    CASE WHEN u.usuario_id IS NOT NULL THEN TRUE ELSE FALSE END as tiene_usuario
  FROM miembro_acaucab ma
  LEFT JOIN usuario u ON ma.miembro_id = u.fk_miembro_acaucab
  ORDER BY ma.razon_social;
END;
$$;

CREATE OR REPLACE FUNCTION get_nomina_departamento(
  p_fecha_inicio DATE DEFAULT NULL,
  p_fecha_fin DATE DEFAULT NULL,
  p_limite INTEGER DEFAULT 100
)
RETURNS TABLE (
  departamento_id INTEGER,
  nombre_departamento VARCHAR,
  cargo_id INTEGER,
  nombre_cargo VARCHAR,
  empleado_id INTEGER,
  cedula INTEGER,
  nombre_completo VARCHAR,
  fecha_contrato DATE,
  salario_base INTEGER,  -- Cambiado de NUMERIC a INTEGER
  total_beneficios INTEGER,  -- Cambiado de NUMERIC a INTEGER
  costo_total INTEGER,  -- Cambiado de NUMERIC a INTEGER
  fecha_inicio_cargo DATE,
  fecha_fin_cargo DATE,
  estado_empleado VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    d.departamento_id,
    d.nombre::VARCHAR as nombre_departamento,
    c.cargo_id,
    c.nombre::VARCHAR as nombre_cargo,
    e.empleado_id,
    e.cedula,
    CONCAT(
      e.primer_nombre, ' ',
      COALESCE(e.segundo_nombre, ''), ' ',
      e.primer_apellido, ' ',
      COALESCE(e.segundo_apellido, '')
    )::VARCHAR as nombre_completo,
    e.fecha_contrato,
    de.salario::INTEGER as salario_base,  -- Cast explícito a INTEGER
    COALESCE(SUM(be.monto), 0)::INTEGER as total_beneficios,  -- Cast explícito a INTEGER
    (de.salario + COALESCE(SUM(be.monto), 0))::INTEGER as costo_total,  -- Cast explícito a INTEGER
    de.fecha_inicio as fecha_inicio_cargo,
    de.fecha_fin as fecha_fin_cargo,
    CASE 
      WHEN de.fecha_fin IS NULL OR de.fecha_fin >= CURRENT_DATE THEN 'ACTIVO'
      ELSE 'INACTIVO'
    END::VARCHAR as estado_empleado
  FROM DEPARTAMENTO d
  INNER JOIN DEPARTAMENTO_EMPLEADO de ON d.departamento_id = de.fk_departamento
  INNER JOIN EMPLEADO e ON de.fk_empleado = e.empleado_id
  INNER JOIN CARGO c ON de.fk_cargo = c.cargo_id
  LEFT JOIN BENEFICIO_EMPLEADO be ON e.empleado_id = be.fk_empleado
  WHERE (p_fecha_inicio IS NULL OR de.fecha_inicio >= p_fecha_inicio)
    AND (p_fecha_fin IS NULL OR de.fecha_inicio <= p_fecha_fin)
    AND (de.fecha_fin IS NULL OR de.fecha_fin >= CURRENT_DATE)
  GROUP BY 
    d.departamento_id, d.nombre, c.cargo_id, c.nombre,
    e.empleado_id, e.cedula, e.primer_nombre, e.segundo_nombre, e.primer_apellido, e.segundo_apellido,
    e.fecha_contrato, de.salario, de.fecha_inicio, de.fecha_fin
  ORDER BY d.nombre, c.nombre, e.primer_apellido, e.primer_nombre
  LIMIT p_limite;
END;
$$;

create function get_historial_compras_cliente_juridico(p_cliente_juridico_id integer, p_fecha_inicio date DEFAULT NULL::date, p_fecha_fin date DEFAULT NULL::date, p_limite integer DEFAULT 100)
    returns TABLE(razon_social character varying, rif character varying, fecha_emision date, producto character varying, cantidad integer, monto numeric, total_compra numeric)
    language plpgsql
as
$$
BEGIN
  RETURN QUERY
  SELECT
    cj.razon_social,
    cj.rif,
    vo.fecha_emision,
    c.nombre as producto,
    dvo.cantidad,
    (dvo.precio_unitario * dvo.cantidad)::numeric as monto,
    vo.total::numeric as total_compra
  FROM cliente_juridico cj
  JOIN usuario u ON cj.cliente_id = u.fk_cliente_juridico
  JOIN venta_online vo ON u.usuario_id = vo.fk_usuario
  JOIN detalle_venta_online dvo ON vo.venta_online_id = dvo.fk_venta_online
  JOIN almacen_cerveza ac ON dvo.fk_almacen_cerveza = ac.almacen_cerveza_id
  JOIN cerveza_presentacion cp ON ac.fk_cerveza_presentacion = cp.cerveza_presentacion_id
  JOIN cerveza c ON cp.fk_cerveza = c.cerveza_id
  WHERE
    (p_cliente_juridico_id IS NULL OR cj.cliente_id = p_cliente_juridico_id)
    AND (p_fecha_inicio IS NULL OR vo.fecha_emision >= p_fecha_inicio)
    AND (p_fecha_fin IS NULL OR vo.fecha_emision <= p_fecha_fin)
  ORDER BY vo.fecha_emision DESC
  LIMIT COALESCE(p_limite, 100);
END;
$$;

CREATE OR REPLACE FUNCTION buscarCliente(
    p_tipo_cliente VARCHAR,
    p_identificacion VARCHAR
)
    RETURNS SETOF record
    LANGUAGE plpgsql
AS $$
BEGIN
    IF p_tipo_cliente = 'natural' THEN
        RETURN QUERY
            SELECT n.cliente_id, n.primer_nombre, n.segundo_nombre, n.cedula, n.direccion, n.total_puntos, n.rif, n.primer_apellido, n.segundo_apellido
            FROM cliente_natural n
            WHERE n.cedula = p_identificacion::integer;

    ELSIF p_tipo_cliente = 'juridico' THEN
        RETURN QUERY
            SELECT j.cliente_id, j.razon_social, j.rif, j.direccion, j.total_puntos
            FROM cliente_juridico j
            WHERE j.rif = p_identificacion;
    END IF;

    RETURN;
END;
$$;
create function create_venta_online(user_id integer, total_amount integer, delivery_address character varying) returns integer
    language plpgsql
as
$$
DECLARE
    new_venta_id INTEGER;
    lugar_id INTEGER;
    fecha_estimada DATE;
BEGIN
    -- Obtener el lugar por defecto
    SELECT l.lugar_id INTO lugar_id FROM LUGAR l LIMIT 1;
    IF lugar_id IS NULL THEN
        lugar_id := 1;
    END IF;

    -- Calcular fecha estimada de entrega (3 días después)
    fecha_estimada := CURRENT_DATE + INTERVAL '3 days';

    -- Insertar la venta online
    INSERT INTO VENTA_ONLINE (
        direccion,
        fecha_emision,
        fecha_estimada,
        total,
        fk_lugar,
        fk_usuario
    ) VALUES (
        delivery_address,
        CURRENT_DATE,
        fecha_estimada,
        total_amount,
        lugar_id,
        user_id
    ) RETURNING venta_online_id INTO new_venta_id;

    RETURN new_venta_id;
END;
$$;


-- Crear detalle de venta online
CREATE OR REPLACE FUNCTION create_detalle_venta_online(
    venta_online_id INTEGER,
    almacen_cerveza_id INTEGER,
    precio_unitario INTEGER,
    cantidad INTEGER
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO DETALLE_VENTA_ONLINE (
        fk_almacen_cerveza,
        fk_venta_online,
        precio_unitario,
        cantidad
    ) VALUES (
        almacen_cerveza_id,
        venta_online_id,
        precio_unitario,
        cantidad
    );
END;
$$ LANGUAGE plpgsql;
create function create_estado_venta_online(venta_online_id integer) returns void
    language plpgsql
as
$$
DECLARE
    estado_id INTEGER;
BEGIN
    -- Buscar estado "Pendiente"
    SELECT e.estado_id INTO estado_id FROM ESTADO e WHERE nombre = 'Pendiente' LIMIT 1;
    IF estado_id IS NULL THEN
        estado_id := 1;
    END IF;

    INSERT INTO ESTADO_VENTA_ONLINE (
        fecha_inicio,
        fk_estado,
        fk_venta_online
    ) VALUES (
        CURRENT_DATE,
        estado_id,
        venta_online_id
    );
END;
$$;



-- Encontrar almacén cerveza por nombre de producto
CREATE OR REPLACE FUNCTION find_almacen_cerveza_by_product_name(product_name VARCHAR)
RETURNS INTEGER AS $$
DECLARE
    almacen_id INTEGER;
BEGIN
    SELECT ac.almacen_cerveza_id INTO almacen_id
    FROM ALMACEN_CERVEZA ac
    JOIN CERVEZA_PRESENTACION cp ON ac.fk_cerveza_presentacion = cp.cerveza_presentacion_id
    JOIN CERVEZA c ON cp.fk_cerveza = c.cerveza_id
    WHERE c.nombre ILIKE '%' || split_part(product_name, ' ', 1) || '%'
    LIMIT 1;
    
    RETURN almacen_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_ventas_online_by_user_id(user_id INTEGER)
RETURNS TABLE (
    venta_online_id INTEGER,
    fecha_emision DATE,
    fecha_estimada DATE,
    fecha_entrega DATE,
    total INTEGER,
    direccion VARCHAR,
    estado VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        vo.venta_online_id,
        vo.fecha_emision,
        vo.fecha_estimada,
        vo.fecha_entrega,
        vo.total,
        vo.direccion,
        COALESCE(latest_estado.nombre, 'Pendiente') as estado
    FROM VENTA_ONLINE vo
    LEFT JOIN (
        SELECT DISTINCT ON (evo.fk_venta_online) 
            evo.fk_venta_online,
            e.nombre
        FROM ESTADO_VENTA_ONLINE evo
        JOIN ESTADO e ON evo.fk_estado = e.estado_id
        ORDER BY evo.fk_venta_online, evo.fecha_inicio DESC
    ) latest_estado ON vo.venta_online_id = latest_estado.fk_venta_online
    WHERE vo.fk_usuario = user_id
    ORDER BY vo.fecha_emision DESC;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_detalles_venta_online(venta_online_id INTEGER)
RETURNS TABLE (
    detalle_venta_online_id INTEGER,
    nombre_cerveza VARCHAR,
    presentacion VARCHAR,
    precio_unitario INTEGER,
    cantidad INTEGER,
    subtotal INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT DISTINCT
        dvo.detalle_venta_online_id,
        c.nombre::VARCHAR as nombre_cerveza,
        (p.cap_volumen::VARCHAR || 'ml ' || p.material)::VARCHAR as presentacion,
        dvo.precio_unitario,
        dvo.cantidad,
        (dvo.precio_unitario * dvo.cantidad) as subtotal
    FROM DETALLE_VENTA_ONLINE dvo
    JOIN ALMACEN_CERVEZA ac ON dvo.fk_almacen_cerveza = ac.almacen_cerveza_id
    JOIN CERVEZA_PRESENTACION cp ON ac.fk_cerveza_presentacion = cp.cerveza_presentacion_id
    JOIN CERVEZA c ON cp.fk_cerveza = c.cerveza_id
    JOIN PRESENTACION p ON cp.fk_presentacion = p.presentacion_id
    WHERE dvo.fk_venta_online = get_detalles_venta_online.venta_online_id
    ORDER BY dvo.detalle_venta_online_id;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION get_usuario_by_id_complete(p_usuario_id INTEGER)
RETURNS TABLE (
    -- Información básica del usuario
    usuario_id INTEGER,
    nombre_usuario VARCHAR,
    fecha_creacion DATE,
    
    -- Claves foráneas para identificar el tipo de entidad
    fk_empleado INTEGER,
    fk_cliente_natural INTEGER,
    fk_cliente_juridico INTEGER,
    fk_miembro_acaucab INTEGER,
    
    -- Información de empleado (si aplica)
    empleado_id INTEGER,
    emp_primer_nombre VARCHAR,
    emp_segundo_nombre VARCHAR,
    emp_primer_apellido VARCHAR,
    emp_segundo_apellido VARCHAR,
    emp_direccion VARCHAR,
    
    -- Información de cliente natural (si aplica)
    cn_cliente_id INTEGER,
    cn_primer_nombre VARCHAR,
    cn_segundo_nombre VARCHAR,
    cn_primer_apellido VARCHAR,
    cn_segundo_apellido VARCHAR,
    cn_direccion VARCHAR,
    cn_total_puntos INTEGER,
    
    -- Información de cliente jurídico (si aplica)
    cj_cliente_id INTEGER,
    cj_razon_social VARCHAR,
    cj_direccion VARCHAR,
    cj_total_puntos INTEGER,
    
    -- Información de miembro ACAUCAB (si aplica)
    ma_miembro_id INTEGER,
    ma_razon_social VARCHAR,
    ma_direccion VARCHAR,
    
    -- Campo calculado para identificar el tipo de entidad
    tipo_entidad VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.usuario_id,
        u.nombre_usuario,
        u.fecha_creacion,
        
        -- Claves foráneas
        u.fk_empleado,
        u.fk_cliente_natural,
        u.fk_cliente_juridico,
        u.fk_miembro_acaucab,
        
        -- Datos de empleado
        e.empleado_id,
        e.primer_nombre as emp_primer_nombre,
        e.segundo_nombre as emp_segundo_nombre,
        e.primer_apellido as emp_primer_apellido,
        e.segundo_apellido as emp_segundo_apellido,
        e.direccion as emp_direccion,
        
        -- Datos de cliente natural
        cn.cliente_id as cn_cliente_id,
        cn.primer_nombre as cn_primer_nombre,
        cn.segundo_nombre as cn_segundo_nombre,
        cn.primer_apellido as cn_primer_apellido,
        cn.segundo_apellido as cn_segundo_apellido,
        cn.direccion as cn_direccion,
        cn.total_puntos as cn_total_puntos,
        
        -- Datos de cliente jurídico
        cj.cliente_id as cj_cliente_id,
        cj.razon_social as cj_razon_social,
        cj.direccion as cj_direccion,
        cj.total_puntos as cj_total_puntos,
        
        -- Datos de miembro ACAUCAB
        ma.miembro_id as ma_miembro_id,
        ma.razon_social as ma_razon_social,
        ma.direccion as ma_direccion,
        
        -- Determinar el tipo de entidad
        CASE 
            WHEN u.fk_empleado IS NOT NULL THEN 'empleado'
            WHEN u.fk_cliente_natural IS NOT NULL THEN 'cliente_natural'
            WHEN u.fk_cliente_juridico IS NOT NULL THEN 'cliente_juridico'
            WHEN u.fk_miembro_acaucab IS NOT NULL THEN 'miembro_acaucab'
            ELSE 'sin_entidad'
        END as tipo_entidad
        
    FROM usuario u
    LEFT JOIN empleado e ON u.fk_empleado = e.empleado_id
    LEFT JOIN cliente_natural cn ON u.fk_cliente_natural = cn.cliente_id
    LEFT JOIN cliente_juridico cj ON u.fk_cliente_juridico = cj.cliente_id
    LEFT JOIN miembro_acaucab ma ON u.fk_miembro_acaucab = ma.miembro_id
    WHERE u.usuario_id = p_usuario_id;
END;
$$;
